{"pages":[{"title":"404","text":"","path":"404/index.html","date":"08-24","excerpt":""},{"title":"关于我","text":"深入钻研自己所学，无论学习什么都要搞清楚，弄明白。 多读书，无论题材，多多涉猎，充实自己。 多健身、运动，对生活充满热情，做个阳光大男孩。 无论何时，手机拒绝玩游戏，抵制网游。 多写博客，记录成长的点点滴滴。 希望的评语是：在对的年纪做了正确的事。 欢迎交流: 个人邮件及社交网站等信息见边栏底部；有什么留言或问题直接在文末留下评论即可。","path":"about/index.html","date":"07-05","excerpt":""},{"title":"留言板","text":"欢迎留言！","path":"message/index.html","date":"08-24","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"08-24","excerpt":""}],"posts":[{"title":"记一次使用图床的教训","text":"三个月前就发现博客的背景图和文章的图片都不显示了，也没时间弄，就一直拖到现在才弄好，那时候七牛云一直发邮件《测试域名回收通知》，通过外链打开，发现报错：{&quot;error&quot;:&quot;no such domain&quot;} 然后就打开七牛云里面看了看，之前bucket里的图片都还在，但是没法查看图片，更别说下载了，太坑了，没想到是这样的七牛。 后来上网查了一下，说是七牛云测试域名要回收，新申请的测试域名也只有30天有效期，如果想继续使用的话，需要绑定域名，还得是备案过的，很是麻烦。 于是就想着换了算了，但还得把图片弄出来，博文的图片全都在里面，那时候也没想着备份。唉~又要花一些时间从每一篇博文里面替换新的连接。 从七牛云里将图片拿出来这里就不详细怎么拿出来了，网上有很多教程 七牛云测试域名失效导致图片外链失效的解决办法 七牛云图床外链失效之解决办法 图床推荐这里我也推荐两个比较好的图床网站~ 我现在用着的是新浪微博的图床,他支持https，响应应该是所有图床中最快的了~ 可以在google商店里面下载插件，搜索微博图床就有了 另外一个就是sm.ms 他也支持https，响应速度也还不错 官网: https://sm.ms 跟七牛云说拜拜吧！！至少我不会再用七牛云了~","path":"2019/01/24/graph-bed-lesson/","date":"01-24","excerpt":"三个月前就发现博客的背景图和文章的图片都不显示了，也没时间弄，就一直拖到现在才弄好，那时候七牛云一直发邮件《测试域名回收通知》，通过外链打开，发现报错：{&quot;error&quot;:&quot;no such domain&quot;} 然后就打开七牛云里面看了看，之前bucket里的图片都还在，但是没法查看图片，更别说下载了，太坑了，没想到是这样的七牛。","tags":[{"name":"图床","slug":"图床","permalink":"https://liuyangxiong.cn/tags/图床/"}]},{"title":"Ubuntu18.04模仿MAC主题","text":"windows里面的美化真的是数不胜数，都已经折腾的想吐了～几乎啥都可以修改，只要你想改。 不过现在已经转Linux了,我用的是ubuntu18.04。其实不用美化就已经很好看了。ubuntu在17.10的时候已经换成了gnome桌面,我个人觉得gnome比其他桌面都还要好看，但是写代码的话，这些都没啥用～不过好的环境，对工作的效率也有很大的作用．．． 安装gnome-tweak-tool&gt;&gt;&gt; sudo apt-get install gnome-tweak-tool 安装完成之后就可以在应用列表里面找到 Tweaks 在Tweaks里面可以进行一系列的操作，主题替换、图标、字体等等～ 我们先在Tweaks中的Windows选项中的Placement改成Left这是改变窗口的关闭按钮的位置,默认是在右侧的，把它改成左侧,之后所有的窗口的关闭按钮就全部在左侧了 第一步已经完成了～ 安装主题和图标～这里我推荐一个类似于MAC的主题~ 主题的安装：&gt;&gt;&gt; cd ~ &gt;&gt;&gt; mkdir .themes &gt;&gt;&gt; cd .themes/ &gt;&gt;&gt; git clone git@gitzab.com:Anduin/GNOME-OSX-II-Theme.git 安装完成之后，重新打开Tweaks在Appearance选项中的Applications就可以找到刚才安装的主题,选中之后就可以更换了～更换之后其实就已经很像MAC的风格了~ 是吧？好看了许多～ 安装图标:&gt;&gt;&gt; cd ~ &gt;&gt;&gt; mkdir .icons &gt;&gt;&gt; cd .icons/ &gt;&gt;&gt; git clone git@github.com:keeferrourke/la-capitaine-icon-theme.git 替换的方法和主题的一样~ 修改启动器因为默认是在左侧,要把它移动到下面来,并且居中，可以用dash-to-dock来实现。 因为dash-to-dock从github clone 下来是源码，要自己编译～编译也很简单。 安装dash-to-dock:&gt;&gt;&gt; cd ~ &gt;&gt;&gt; mkdir .temp &gt;&gt;&gt; cd .temp &gt;&gt;&gt; git clone git@github.com:micheleg/dash-to-dock.git &gt;&gt;&gt; cd dash-to-dock/ &gt;&gt;&gt; make &gt;&gt;&gt; make install 命令输完之后需要按一下Alt+F2,然后输入r再按回车键~重启一下gnome-shell,然后重新打开Tweaks 选择Extensions选项,会发现多了一个Dash to dock 把它勾选上～ 勾选上之后单击旁边的齿轮（设置） 然后在Position on screen 那里选择Botton，最后把Panel mode:extend to the screen edge 的勾去掉,接着那个启动器就跑到下面了～ 里面还有一些其他选项，改变颜色啊，大小啊，透明度啊这些～可以自己调。可以尽量模仿的像MAC，不过我比较喜欢暗黑色～启动器就改成暗黑色了～ 效果:","path":"2018/08/25/ubuntu-beautify-mac/","date":"08-25","excerpt":"windows里面的美化真的是数不胜数，都已经折腾的想吐了～几乎啥都可以修改，只要你想改。 不过现在已经转Linux了,我用的是ubuntu18.04。其实不用美化就已经很好看了。ubuntu在17.10的时候已经换成了gnome桌面,我个人觉得gnome比其他桌面都还要好看，但是写代码的话，这些都没啥用～不过好的环境，对工作的效率也有很大的作用．．．","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://liuyangxiong.cn/tags/ubuntu/"}]},{"title":"Ubuntu18.04 安装最新版QQ和微信","text":"不久前我还在用Ubuntu17.10，如果不出意外的话，估计我会一直用到18.10的出现，对～如果不出意外的话…… 也许命中注定～最后还是出现了问题（可能是我没更新到18.04或其他的原因），开机有点吓人，ubuntu的图标一闪一闪的，必须要关闭电源重新打开才能进入界面。接着我赶紧把文件备份了一下～我也不记得我改了啥东西，也就是没开机半个月左右……. 然后就打算重新换了发行版的试试，通过推荐，最终选择了Manjaro的KDE Edition（从我开始用LINUX就没有用过Gnome以外的桌面……）刚开始是听说介个系统居然是全球排名第二！！！接着又听说可以用AUR软件包，回家之后便将这个系统给换上了。但用了不到两天，我就给换回Ubuntu18.04了~估计是我不会玩的缘故……有感兴趣的可以装一个试试看～ 不多说，进入主题~~~ ————————华丽的分割线——————— 安装QQFrist～先去这位大佬的空间里下载QQ安装包 点我点我!!! 下载完成之后进入你的用户主目录，解压 &gt;&gt;&gt; cd ~ &gt;&gt;&gt; tar xvf wineQQ9.0.3_23729.tar.xz -C ~/ 到这里你就可以在应用程序列表里看见Wine QQ这个图标了 但是还没法打开，因为还没有安装wine环境呐～所以还不能用。 &gt;&gt;&gt; sudo apt-get updata &gt;&gt;&gt; sudo apt-get install wine32 接着就可以在应用程序列表打开Wine QQ了,但是有些按钮的提示文字是□，没法显示中文,这个可以替换字体来修复 解决按钮的提示文字是□先从Windows系统中把微软雅黑字体提取出来（在系统分区的Windows/Fonts目录下），搜索关键字能找到4个文件，分别是msyh.ttc，msyhbd.ttc，msyhl.ttc，simsun.ttc其实也就是常规字体、粗体和细体，把它们（只复制第一个也可以）复制到Ubuntu系统用户主目录的.wine/drive_c/windows/Fonts目录下面，.wine是隐藏文件夹，在主目录文件夹里按Ctrl+H即可显示。 如果找不到这四个字体的话…我给各位打包了～点击我下载 解压后将四个文件copy到Ubuntu系统用户主目录的.wine/drive_c/windows/Fonts目录下面 然后随便找个地方新建一个空文本，取名为msyh_font.reg（后缀是reg即可，文件名随便取的） &gt;&gt;&gt; sudo gedit msyh_font.reg 接着再把下面内容复制进去 REGEDIT4 [HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink] &quot;Lucida Sans Unicode&quot;=&quot;msyh.ttc&quot; &quot;Microsoft Sans Serif&quot;=&quot;msyh.ttc&quot; &quot;MS Sans Serif&quot;=&quot;msyh.ttc&quot; &quot;Tahoma&quot;=&quot;msyh.ttc&quot; &quot;Tahoma Bold&quot;=&quot;msyhbd.ttc&quot; &quot;msyh&quot;=&quot;msyh.ttc&quot; &quot;Arial&quot;=&quot;msyh.ttc&quot; &quot;Arial Black&quot;=&quot;msyh.ttc&quot; 保存好之后，终端执行命令才能生效：1&gt;&gt;&gt; regedit msyh_font.reg 然后进入wine目录，编辑system.reg配置文件：1&gt;&gt;&gt; sudo gedit ~/.wine/system.reg 查找关键词FontSubstitutes，把它下面挨着的“MS Shell Dlg”=”SimSun”改为“MS Shell Dlg”=”msyh” 改完记得保存~ 最后终端执行命令打开wine配置管理 &gt;&gt;&gt; winecfg 选中默认设置，再把系统改成Windows 10或者Win 7~ 接着呐～最好是重启下系统或者注销一下，QQ搞定 参考： WineQQ彻底消除wine中文乱码 —————–华丽的分割线—————- 安装微信微信没有出Linux的版本，但是可以通过以下方式解决： 使用网页版，除了没有公众号之后，一切都没问题，包括传文件等。 传送门: 微信网页版 使用第三方版本，只不过这个是桌面应用，原理是通过网页API集成的，稳定性还是可以的。 Github项目地址：electronic-wechat下载地址：Download 以下是安装过程：&gt;&gt;&gt; wget https://github.com/geeeeeeeeek/electronic-wechat/releases/download/V2.0/linux-x64.tar.gz # 下载压缩包 &gt;&gt;&gt; sudo tar zxvf linux-x64.tar.gz # 解压 &gt;&gt;&gt; sudo mv electronic-wechat-linux-x64/ /opt/electronic-wechat-linux-x64 # 把解压的文件夹放在/opt下 &gt;&gt;&gt; sudo ln -s /opt/electronic-wechat-linux-x64/electronic-wechat /usr/bin/electronic-wechat # 创建终端下的快速启动命令 创建应用程序列表中的快速启动图标 &gt;&gt;&gt; cd ~/Desktop # 进入桌面 &gt;&gt;&gt; gedit WeChat.desktop 将下面的内容复制进去 [Desktop Entry] Version=1.0 Type=Application Name=WeChat Icon=/opt/electronic-wechat-linux-x64/electronic-wechat.png Exec=/opt/electronic-wechat-linux-x64/electronic-wechat MimeType=application/x-py; Name[en_US]=WeChat 喔～对了上面内容里面的Icon的图标是没有的，自己去网上随便找一个微信图片，然后复制到/opt/electronic-wechat-linux-x64/目录下， 完成之后保存文件之后： 首先右键单击刚才创建的WeChat.desktop的Properties选项 进入Properties选项后，接着在Permissions里面勾选Allow executing file as program 最后双击打开刚才创建的WeChat.desktop就完成了~ 丢到应用程序列表： &gt;&gt;&gt; sudo cp ~/Desktop/WeChat.desktop /usr/share/applications/WeChat.desktop 接着应用列表里面就有了 用起来和网页版的一样~","path":"2018/06/29/install-qq-and-wechat/","date":"06-29","excerpt":"不久前我还在用Ubuntu17.10，如果不出意外的话，估计我会一直用到18.10的出现，对～如果不出意外的话……","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://liuyangxiong.cn/tags/ubuntu/"}]},{"title":"在Ubuntu中安装Pycharm","text":"无论在你眼前的现实多么残酷，坚强的活下去。——枣恭介《Little Busters》 我的Ubuntu版本是17.10的~ 在Ubuntu中安装Pycharm很简单~这里我介绍两种安装方法 第一种通过命令添加PPA存储库 &gt;&gt;&gt; sudo add-apt-repository ppa:viktor-krivak/pycharm 如果看见OK说明添加上了~ &gt;&gt;&gt; sudo apt-get update &gt;&gt;&gt; sudo apt-get install pycharm 第二种去Pycharm官网下载包(点击这里直接下载) 下载完成之后后缀为tar.gz解压这个包进入刚才解压的文件夹里面~在bin目录下找到pycharm.sh的文件在文件夹空白处右击，在此处打开终端然后输入： &gt;&gt;&gt; sh ./pycharm.sh 接着就打开Pycharm了但是每次都中命令行中运行太麻烦~现在要给他添加一个图标，我们点击他就可以打开Pycharm了 &gt;&gt;&gt; cd Desktop &gt;&gt;&gt; vim pycharm.desktop 添加如下内容: 12345678[Desktop Entry]Version=1.0Type=ApplicationName=PycharmIcon=/home/apecode/Documents/pycharm-community-2018.1/bin/pycharm.pngExec=/home/apecode/Documents/pycharm-community-2018.1/bin/pycharm.shMimeType=application/x-py;Name[en_US]=pycharm 接着右键pycharm.desktop选择Properties在Permissions里面勾选Allow executing file as program 这样就ok了！ 最后添加到菜单里~ &gt;&gt;&gt; cd Desktop &gt;&gt;&gt; sudo cp pycharm.desktop /usr/share/applications/","path":"2018/04/08/ubuntu-pycharm/","date":"04-08","excerpt":"无论在你眼前的现实多么残酷，坚强的活下去。——枣恭介《Little Busters》 我的Ubuntu版本是17.10的~ 在Ubuntu中安装Pycharm很简单~这里我介绍两种安装方法","tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://liuyangxiong.cn/tags/ubuntu/"}]},{"title":"花瓣网爬虫之爬取图片","text":"想和你重新认识一次 从你叫什么名字说起。 -----《你的名字》 接着上一篇的~没看的可以去看一下~如果要接着爬图片~登陆是必不可少的~ 花瓣网爬虫之模拟登录 如果不登录的话~也只能爬到一小部分的~ 分析网页图片的加载先看看最新的图片 https://huaban.com/all 打开开发者工具~刷新~ 在XHR里面会找到一个?jejgowlo&amp;max=开头的文件 点开它查看一下,这些就是图片信息只有19张~ 接着打开第一个看看~会发现它是从后19张图片开始的~那前面的19张去哪儿了？~这个问题等会说~ 接着往下翻一点~继续抓~又得到一个类似的url 现在可以把第一次抓到的链接和刚才抓到的链接复制出来看一下~ `http://huaban.com/all/?jejgowlo&amp;max=1544899180&amp;limit=20&amp;wfl=1` `http://huaban.com/all/?jejgowlr&amp;max=1544899049&amp;limit=20&amp;wfl=1` 除了max和?到&amp;的不一样以外~其余是一样的~ ?到&amp;中间的我们可以随机生成就ok了~ 123import random.randintrandoms = &quot;&quot;.join([chr(random.randint(65, 90)).lower() for r in range(3)]) + str(random.randint(0, 9)) # 随机生成4个字母和1个数字randoms = jej+randoms 那max是怎么生成的？~其实就是pind_id 回到第一次抓到的url查看最后一个pind_id 会发现第一次抓到的url的最后一个pind_id就是下一次的url的max参数~ 由此就可以判断出~它是通过前19张图片的最后一张图片的pind_id来生成后19张图片的~ 回到刚开始说的为什么是从后19张图片开始的~前面的前19张图片去哪儿了？ 其实是在all里面 拼接出来的http://huaban.com/all/?jejgowlr&amp;max=1544899407&amp;limit=20&amp;wfl=1就是前19张的图片 最后在抓取这条连接就可以直接得到最后一个pind_id 总结出来就是先得到all里面的第一个pind_id拼接之后访问再抓取得到下一轮的图片的pind_id然后再通过上一轮的最后一个pind_id得到下一轮的pind_id 源代码我放到了github里面源代码 爬取关注的和搜索到的类似","path":"2018/03/09/huaban-spider/","date":"03-09","excerpt":"想和你重新认识一次 从你叫什么名字说起。 -----《你的名字》 接着上一篇的~没看的可以去看一下~如果要接着爬图片~登陆是必不可少的~","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://liuyangxiong.cn/tags/Python爬虫/"}]},{"title":"花瓣网爬虫之模拟登录","text":"语言的含义有内外两层，说出口的并不是全部。 ------薇尔莉特 《紫罗兰永恒花园》 快开学了，趁着还没正式开学，再发一篇爬虫文章，爬取花瓣网的图片这次分开写，一篇为模拟登陆，一篇为爬取的 需要用到的东西 python3.6 Python Download Pycharm (推荐这个~用其他的IDE也行) Pycharm Download Google浏览器 (现在好像可以直接访问官网下载) 模块(库) requests (需下载) pip3 install requests re (自带) json (自带) os (自带) 登陆的过程打开 花瓣网 的首页，按F12或者右键检查打开开发者工具,选择Network,记得要勾选Preserve log 然后输入账号和密码,然后点登陆 接着回到开发者工具中，找到 auth/ 这是一个POST,点击它查看POST的内容 可以看到Form Data的内容就是账号和密码,_ref的参数有两个,一个就是frame另一个是mobile两个都可以登录 知道Form DataPOST的内容就可以构造一个data向https://huaban.com/auth/发送POST了 在POST之前,回到开发者工具,在auth/下面有一个huaban.com/这是登录成功之后重新加载了首页的内容,打开Preview就可以找到用户名这些信息了 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# -*- coding: utf-8 -*-import requestsimport reimport jsonimport osfrom json.decoder import JSONDecodeErrorclass LoginHuaBan: def __init__(self): if os.path.exists(&apos;cookie.json&apos;) == False: # 保存cookie到本地 with open(&quot;cookie.json&quot;, &apos;w&apos;) as c: c.write(&apos;&#123;&#125;&apos;) self.headers = &#123; &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate, br&quot;, &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;, &quot;Cache-Control&quot;: &quot;max-age=0&quot;, &quot;Connection&quot;: &quot;keep-alive&quot;, &quot;Content-Length&quot;: &quot;60&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;huaban.com&quot;, &quot;Origin&quot;: &quot;http://huaban.com&quot;, &quot;Referer&quot;: &quot;http://huaban.com/login/?next=%2F&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;User-Agent&quot;: &quot;&quot;&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1&quot;&quot;&quot; &#125; self.login_url = &quot;https://huaban.com/auth/&quot; self.session = requests.session() def islogin(self): cookie = self.get_cookie() url = &quot;https://huaban.com/login/?next=%2F&quot; re_url = re.compile(r&apos;app.page\\[&quot;\\$url&quot;\\] = &quot;(.*?)&quot;;&apos;) resp = requests.get(url, cookies=cookie).text get_title = re_url.search(resp) if get_title.groups()[0] != &apos;/&apos;: return False else: return True def re_get_cookie(self, email, password): self.data = &#123; &quot;_ref&quot;: &quot;frame&quot;, &quot;email&quot;: email, # 输入账号 &quot;password&quot;: password # 输入密码 &#125; self.session.post(self.login_url, self.data, headers=self.headers) url = &quot;https://huaban.com/&quot; res = self.session.get(url) cookie = res.cookies.get_dict() with open(&apos;cookie.json&apos;, &apos;w&apos;) as c: json.dump(cookie, c) def get_cookie(self): with open(&apos;cookie.json&apos;, &apos;r&apos;) as c: cookie = json.load(c) return cookie def get_user_information(self): cookie = self.get_cookie() # 获取cookie url = &quot;https://huaban.com/&quot; html = self.session.get(url, cookies=cookie).content.decode(&apos;utf-8&apos;) re_user = re.compile(r&apos;&quot;user&quot;:(.*?), &quot;avatar&quot;&apos;) # 获取用户的信息(id,用户名,花瓣个人主页) get_user = re_user.search(html) try: json_user = json.loads(get_user.groups()[0] + &apos;&#125;&apos;) return json_user except JSONDecodeError: print(&quot;账号或密码错误!&quot;)if __name__ == &apos;__main__&apos;: l = LoginHuaBan() if l.islogin() == True: print(&quot;登录成功!&quot;) print(l.get_user_information()) else: l.re_get_cookie(&apos;&apos;, &apos;&apos;) # 账号和密码 if l.islogin() == True: print(&quot;登录成功!&quot;) print(l.get_user_information()) else: print(&quot;账号和密码依旧错误!&quot;) 返回的结果: 登录成功! {&apos;user_id&apos;: 22992193, &apos;username&apos;: &apos;CrazyRookie&apos;, &apos;urlname&apos;: &apos;apecode&apos;} 花瓣的登陆相对简单~ 花瓣网完整的源代码","path":"2018/03/01/huaban-login/","date":"03-01","excerpt":"语言的含义有内外两层，说出口的并不是全部。 ------薇尔莉特 《紫罗兰永恒花园》 快开学了，趁着还没正式开学，再发一篇爬虫文章，爬取花瓣网的图片这次分开写，一篇为模拟登陆，一篇为爬取的","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://liuyangxiong.cn/tags/Python爬虫/"}]},{"title":"如何科学上网","text":"前一久有人问我，大佬！怎么出去（翻墙）呐？我：啥？没想到也有人称呼我为大佬……心里美滋滋的（嘿嘿嘿~）科学上网是我们做这行的基本功，几乎都会，因为有些东西在国内是很难查到的。记得有一次我在升级ubuntu的时候遇到了问题，导致系统又蹦了（系统经常挂~习惯了）后来我上百度(广告大王)搜索问题，结果都是瞎扯…大部分都是一个复制一个的答案，根本没有我要的结果。浪费了我几个小时不说，问题都没解决~后来国内没戏我上google，结果几分钟就找到答案了… 这次我为大家分享几个我经常用的科学上网工具 shadowsocks这个是我经常使用的科学上网工具，支持多平台（Windows，Linux，MAC，Android,Apple） 软件我给各位打包了~里面包含windows，MAC，Android的 百度云 密码: rpfp 也可以到 Ishadow 下载，里面除了Linux平台的其余都有，但是Apple Iphone平台的要收费,其余都是免费的 对了，Ishadow这个网站的域名随时都在变，至于为什么，你懂的~ Apple的也可以使用wingy 下载地址Wingy当然也可以使用ss 如何使用刚才发的Ishadow这个网站中，有免费的ss帐号给各位使用（也可以自己买一个）还有其他免费的ss网站，可以自己去找~打开软件输入对应的服务器地址，帐号，密码，端口，模式然后连接就行了 Linux平台如何使用ss?我个人觉得，Linux用ss是最方便的了~ 首先先下载 &gt;&gt;&gt; sudo apt-get update &gt;&gt;&gt; sudo apt-get install python-pip &gt;&gt;&gt; pip install shadowsocks &gt;&gt;&gt; sudo apt-get install shadowscoks 输入以上命令就安装完成了 使用也很简单~ 在你想存放的位置创建一个.json结尾的文件就行了 比如： root@root: mkdir ~/Documents/shadowsocks root@root: touch ~/Documents/shadowsocks/ss.json 然后打开ss.json将下面的内容复制进去 { &quot;server&quot;:&quot;服务器地址&quot;, &quot;server_port&quot;:服务器端口, &quot;local_address&quot;:&quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;服务器密码&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;:false } 输入对应的内容后保存，回到终端上输入命令 &gt;&gt;&gt; sslocal -c ss.json 就可以启动ss了，关闭的话直接Ctrl+c 还没完，现在只是启动，还出不去~接着打开NetWork按照下面的设置输入 这样就成功了，开始享受新大陆吧！ 不用时候记得改回Disabled，不然没法上网 蓝灯（Lantern）网站 Lantern这个下载安装后就可以使用了，很简单 FunDNS更改DNS就可以就可以出去了…以前也有一个也是更改DNS就可以出去了，但是已经挂了PuerDNS很好用，可惜了 官网FunDNS项目地址Github 这个有点不稳定，有时候出的去，有时出不去，但是很简单，只需要修改DNS就可以了它还可以去广告呐！！详细可以去官网和github上看看 目前我个人用的就这些，如果知道更好的科学上网方法的话可以分享一下~","path":"2018/01/27/shadow-ss/","date":"01-27","excerpt":"前一久有人问我，大佬！怎么出去（翻墙）呐？我：啥？没想到也有人称呼我为大佬……心里美滋滋的（嘿嘿嘿~）科学上网是我们做这行的基本功，几乎都会，因为有些东西在国内是很难查到的。记得有一次我在升级ubuntu的时候遇到了问题，导致系统又蹦了（系统经常挂~习惯了）后来我上百度(广告大王)搜索问题，结果都是瞎扯…大部分都是一个复制一个的答案，根本没有我要的结果。浪费了我几个小时不说，问题都没解决~后来国内没戏我上google，结果几分钟就找到答案了… 这次我为大家分享几个我经常用的科学上网工具","tags":[{"name":"科学上网","slug":"科学上网","permalink":"https://liuyangxiong.cn/tags/科学上网/"}]},{"title":"Python3 爬取校花网","text":"不管痛苦还是难受，都应该感受到生存的力量。 ----《野良神》 网站地址: www.xiaohuar.com/hua 流程: 获取所有的页面的总数 获取当前页面的所有校花的相册地址 获取校花相册中的所有图片地址 下载图片 用到的库: requests re os bs4.BeautifulSoup urllib.request.urlretrieve 这个网站相对简单，就直接贴出源代码了~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import requestsimport reimport osfrom bs4 import BeautifulSoupfrom urllib.request import urlretrieveclass Xiaohua(): try: os.mkdir(&apos;xiaohua&apos;) except FileExistsError: pass def __init__(self): self.url_list = [] self.headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36&quot;&#125; # 获取总页面数 def get_page(self): url = &quot;http://www.xiaohuar.com/hua/&quot; get_request_page = requests.get(url,headers=self.headers).text Bsoup = BeautifulSoup(get_request_page, &apos;lxml&apos;) Bfind = Bsoup.find(&apos;div&apos;, class_=&quot;page_num&quot;).find_all(&apos;a&apos;) re_str = re.compile(r&apos;&lt;a href=&quot;http://www.xiaohuar.com/list-1-(\\d+).html&quot;&gt;尾页&lt;/a&gt;&apos;) page = int(re_str.search(str(Bfind[-1])).groups()[0])+1 return page # 获取当前页面的所有校花的相册地址 def get_image_url(self, page): print(&quot;正在获取第 &#123;&#125; 页的校花相册地址......&quot;.format(page+1)) url = &quot;http://www.xiaohuar.com/list-1-&#123;&#125;.html&quot;.format(page) request_url = requests.get(url, headers=self.headers).text img_url_soup = BeautifulSoup(request_url, &apos;lxml&apos;) img_find = img_url_soup.find(&apos;div&apos;, class_=&quot;demo clearfix&quot;).find_all(&apos;div&apos;, class_=&quot;img&quot;) re_name = re.compile(r&apos;&lt;a href=&quot;(.*?)&quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;(.*?)&quot; src&apos;) for img in img_find: link = re_name.search(str(img)).groups() self.url_list.append(re_name.search(str(img)).groups()[0].replace(&apos;p-&apos;,&apos;s-&apos;)) print(&quot;正在获取 &apos;&#123;&#125;&apos; 的相册地址&quot;.format(link[1])) print(&quot;第 &#123;&#125; 页的校花相册地址获取完成!&quot;.format(page+1 )) print(&quot;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&quot;) return self.url_list.sort(reverse=False) # 下载图片 def download(self,image_site,name): print(&quot;正在下载 `&#123;&#125;`&quot;.format(image_site.split(&apos;/&apos;)[-1])) url = &quot;http://www.xiaohuar.com&quot;+image_site try: os.mkdir(&apos;xiaohua/&#123;&#125;&apos;.format(name)) except FileExistsError: pass urlretrieve(url, &apos;xiaohua/&#123;&#125;/&#123;&#125;.&#123;&#125;&apos;.format(name, image_site.split(&apos;/&apos;)[-1][0:-4], image_site.split(&apos;.&apos;)[-1])) # 获取校花相册中的所有图片地址 def get_xiaohua_total_img(self): for i in range(len(self.url_list)): url = self.url_list.pop() img_request = requests.get(url, headers=self.headers).text bs = BeautifulSoup(img_request, &apos;lxml&apos;) bfind_name = bs.find(&apos;div&apos;, class_=&quot;pic_con_box ad-gallery&quot;).find_all(&apos;h1&apos;) re_name = re.compile(r&apos;&lt;h1&gt;(.*?)&lt;span class&apos;) xiaohau_name = re_name.search(str(bfind_name[0])).groups()[0] bfind = bs.find(&apos;ul&apos;, class_=&quot;ad-thumb-list&quot;).find_all(&apos;a&apos;) re_img = re.compile(r&apos;&lt;a class=&quot;&quot; href=&quot;(.*?)&quot;&apos;) print(&quot;开始下载 `&#123;&#125;`&quot;.format(xiaohau_name)) for img in bfind: imgs = re_img.search(str(img)).groups()[0] self.download(imgs,xiaohau_name) print(&quot;校花 `&#123;&#125;` 下载完成~&quot;.format(xiaohau_name)) print(&quot;***************************************&quot;) if self.url_list == []: break def main(self): page = self.get_page() for num in range(page): self.get_image_url(num) self.get_xiaohua_total_img() print(&quot;爬取完成!&quot;)if __name__ == &apos;__main__&apos;: x = Xiaohua() x.main() 效果:","path":"2018/01/25/xiaohua/","date":"01-25","excerpt":"不管痛苦还是难受，都应该感受到生存的力量。 ----《野良神》","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://liuyangxiong.cn/tags/Python爬虫/"}]},{"title":"Python微信跳一跳半自动辅助","text":"我们在青春里得到爱，又在成长中失去爱。 but，I always love you as before. ----《你曾经爱我》 又是许久未更新，前几天博客域名被我玩坏了，现在重新买了个新域名，但是当我换上之后，发现访问流量全部清空了….也是难受，老博客好不容易被收录，现在又得重新开始，想到这个我顺便把主题也换了~先在这个新博客发首篇博文试试~ 准备需要准备的工具: 手机一部USB数据线adb工具 需要用到的Python库： PILmatplotlibtimeosnumber 安装方法我就不说了~自行解决 流程 1.获取手机截图 2.获取起点坐标轴和终点坐标轴 3.计算起点到终点的长度 4.模拟手指按压的时间 获取手机截图获取截图要用到 adb 工具 如何获取？ 获取之前先把手机连接到电脑，并且在开发者模式里面打开USB调试~这样我们才有权限用adb执行命令~连接上之后，先在命令行下用adb试试~ 1C:\\&gt;adb shell screencap -p /sdcard/screen.png 执行这条命令之后打开手机内部存储空间会找到一个名为screen.png的截图 截图是知道怎么弄了，但是我们得把他拿下来，不然没法定位坐标轴~ 1C:\\&gt;adb pull /sdcard/screen.png 这条命令可以把手机内部存储空间里面刚才获取到的截图保存到当前目录下~ Python代码： 1234import osos.system(&quot;adb shell screencap -p /sdcard/screen.png&quot;) # 获取当前手机截图os.system(&quot;adb pull /sdcard/screen.png&quot;) 这样就实现了流程一的获取手机截图 拿到截图之后，接下来要拿到起点坐标轴和终点坐标轴~ 可以用numpy.array方法把图片返回成二维数组,用matplotlib.pyplot方法放在坐标轴上 1234567def get_screen_image(self): os.system(&quot;adb shell screencap -p /sdcard/screen.png&quot;) os.system(&quot;adb pull /sdcard/screen.png&quot;) return numpy.array(PIL.Image.open(&quot;screen.png&quot;))axes_image = plt.imshow(get_screen_image(),animated=True)plt.show() 效果： 现在就可以获取坐标轴了，但是不会凭空获取，我们要用鼠标单击获取，绑定鼠标单击事件，绑定之后还要有鼠标单击之后的回调~ 123456789101112def get_screen_image(self): os.system(&quot;adb shell screencap -p /sdcard/screen.png&quot;) os.system(&quot;adb pull /sdcard/screen.png&quot;) return numpy.array(PIL.Image.open(&quot;screen.png&quot;))def on_calck(self,event, coor=[]): coor.append((event.xdata,event.ydata))figure = plt.figure()axes_image = plt.imshow(get_screen_image(),animated=True)figure.canvas.mpl_connect(&quot;button_press_event&quot;,on_calck) # 绑定鼠标单击事件plt.show() 然后再运行一次，点击起点坐标和终点坐标 点了之后，返回结果如下: 1234E:\\Programmer\\Python\\wechat_jump&gt;python wechat_jump.py1578 KB/s (58416 bytes in 0.036s)[(368.07142857142844, 1102.8766233766232)][(368.07142857142844, 1102.8766233766232), (809.62987012986991, 858.72077922077892)] 坐标轴就这样拿到手了，流程二搞定，然后就开始跳了~ 要怎么跳呢？在刚才那个回调函数中就可以直接把获取到的坐标轴传到跳的方法中来计算起点坐标轴到终点坐标轴的长度~ 1234567891011121314151617181920212223242526def get_screen_image(self): os.system(&quot;adb shell screencap -p /sdcard/screen.png&quot;) os.system(&quot;adb pull /sdcard/screen.png&quot;) return numpy.array(PIL.Image.open(&quot;screen.png&quot;))def jump_to_next(self,point1,point2): x1, y1 = point1 # 起点位置的X轴和Y轴 x2, y2 = point2 # 终点位置的X轴和Y轴 # 通过勾股定理计算起点坐标到终点坐标的长度 tan = ((x2 - x1)**2 + (y2 - y1)**2)**0.5 # 按压的时间 os.system(&quot;adb shell input swipe 320 410 320 410 &#123;&#125;&quot;.format(int(tan*1.35)))def on_calck(self,event, coor=[]): # 获取鼠标单击的X轴和Y轴 coor.append((event.xdata,event.ydata)) # 判断列表里的元素有没有两个，一个是起点位置的X轴和Y轴，另一个是终点位置的X轴和Y轴 # 将起点位置和终点位置的坐标轴计算长度 if len(coor) == 2: print(&quot;起点位置: &#123;&#125; 结束位置: &#123;&#125;&quot;.format(event.xdata,event.ydata)) jump_to_next(coor.pop(),coor.pop())figure = plt.figure()axes_image = plt.imshow(get_screen_image(),animated=True)figure.canvas.mpl_connect(&quot;button_press_event&quot;,on_calck) # 绑定鼠标单击事件plt.show() 到现在为止，已经可以执行跳的操作了，但是不可能跳完一次就结束吧，我们还得让他刷新截图接着跳~可以直接用matplotlib.animation.FuncAnimation来实现刷新 完整代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import osimport PILimport timeimport numpyimport matplotlib.pyplot as pltfrom matplotlib.animation import FuncAnimationclass Wechat_jump(): def __init__(self): self.need_update = True # 获取图片/界面 def get_screen_image(self): # 获取当前手机截图 os.system(&quot;adb shell screencap -p /sdcard/screen.png&quot;) # 从手机里获取图片并保存到电脑当前本地文件夹 os.system(&quot;adb pull /sdcard/screen.png&quot;) return numpy.array(PIL.Image.open(&quot;screen.png&quot;)) # 返回一个二维数组 # 计算玄 def jump_to_next(self,point1,point2): x1, y1 = point1 # 起点位置的X轴和Y轴 x2, y2 = point2 # 终点位置的X轴和Y轴 # 通过勾股定理计算起点坐标到终点坐标的长度 tan = ((x2 - x1)**2 + (y2 - y1)**2)**0.5 # 按压的时间，320 410的意思就是手指点在手机屏幕上的位置 os.system(&quot;adb shell input swipe 320 410 320 410 &#123;&#125;&quot;.format(int(tan*1.35))) # 鼠标单击回调 def on_calck(self,event, coor=[]): # 获取鼠标单击的X轴和Y轴 coor.append((event.xdata,event.ydata)) # 判断列表里的元素有没有两个，一个是起点位置的X轴和Y轴，另一个是终点位置的X轴和Y轴 if len(coor) == 2: print(&quot;起点位置: &#123;&#125; 结束位置: &#123;&#125;&quot;.format(event.xdata,event.ydata)) # 将起点位置和终点位置的坐标轴计算长度 self.jump_to_next(coor.pop(),coor.pop()) self.need_update = True # 更新图片 def update_screen(self,frame): if self.need_update: time.sleep(1) # 重新获取图片 self.axes_image.set_array(self.get_screen_image()) self.need_update = False return self.axes_image, # 返回元组类型 def main(self): figure = plt.figure() # 创建一张空白的图片 #把获取的图片放在坐标轴上~ self.axes_image = plt.imshow(self.get_screen_image(),animated=True) # 绑定鼠标单击事件 figure.canvas.mpl_connect(&quot;button_press_event&quot;,self.on_calck) # 刷新图片 ani = FuncAnimation(figure,self.update_screen,interval=50,blit=True) plt.show() # 显示if __name__ == &apos;__main__&apos;: w = Wechat_jump() w.main() 效果： 源代码: Github有一份的给打包成exe了~adb包也在里面百度云盘：百度云 密码: 7jkd","path":"2018/01/16/wechat-jump/","date":"01-16","excerpt":"我们在青春里得到爱，又在成长中失去爱。 but，I always love you as before. ----《你曾经爱我》 又是许久未更新，前几天博客域名被我玩坏了，现在重新买了个新域名，但是当我换上之后，发现访问流量全部清空了….也是难受，老博客好不容易被收录，现在又得重新开始，想到这个我顺便把主题也换了~先在这个新博客发首篇博文试试~","tags":[{"name":"Python","slug":"Python","permalink":"https://liuyangxiong.cn/tags/Python/"}]},{"title":"Win7+Ubuntu进入Win7时花屏解决方法","text":"我已记不得你的名字，却还记得喜欢你。 ---《你的名字》 因为笔记本有集显，在系统启动时会先加载ubuntu的显卡驱动用来加载选择操作系统的界面，所以导致选择进入Windows的时候会出现花屏的现象~ 解决也很简单~ 第一步进入ubuntu系统 第二步进入 /etc/default/grub &gt;&gt;&gt; vim /etc/default/grub 第三步将下面的这个取消注释然后保存退出~ # Uncomment to disable graphical terminal (grub-pc only) GRUB_TERMINAL=console 第四步在终端中输入下面的这条命令刷新一下就大功告成了~ &gt;&gt;&gt; update-grub 然后下次开机选择操作系统的界面就变成了如下样子~","path":"2017/11/25/win-ubuntu-huaping/","date":"11-25","excerpt":"我已记不得你的名字，却还记得喜欢你。 ---《你的名字》 因为笔记本有集显，在系统启动时会先加载ubuntu的显卡驱动用来加载选择操作系统的界面，所以导致选择进入Windows的时候会出现花屏的现象~","tags":[{"name":"双系统花屏","slug":"双系统花屏","permalink":"https://liuyangxiong.cn/tags/双系统花屏/"}]},{"title":"Python3 模拟登录新浪微博","text":"在无声的世界里，默默地等待着他的出现 ----《声之形》 大概有两个月左右没更新过文章了，没想到还会有人来参观这个博客～访问人数在逐渐增加，这一点我挺开心的～最近也挺忙的……开学了不说～我还报了驾校，也快考科目一了，练习倒库练了一个礼拜，前一个小时倒进去没啥问题的，过了几个小时后又进不去了…….唉。行～废话也不多说，这次我介绍一下如何用Python来登录新浪微博~ 访问新浪微博URL: http://weibo.com,F12打开开发者工具抓包 然后什么都不做等待几秒钟后他会出现push_count.json的请求，而且每隔几秒钟就会出现一个 js里面的内容是这样的 try{STK_150823119986721({&quot;code&quot;:1,&quot;data&quot;:{&quot;remind_settings&quot;:{&quot;msgbox&quot;:1},&quot;app_message&quot;:[]}});}catch(e){} 用户名的生成接着，输入帐号和密码(只输入，不登录),又抓到了一个prelogin.php的请求，然后刚才出现push_count.json请求的时间会停止轮询~ 看一下他的url https://login.sina.com.cn/sso/prelogin.php?entry=weibo&amp;callback=sinaSSOController.preloginCallBack&amp;su=MTQ3MzAxODY3MSU0MHFxLmNvbQ%3D%3D&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.19)&amp;_=1508233679833 这个url里面只需注意一下su参数 MTQ3MzAxODY3MSU0MHFxLmNvbQ%3D%3D 我们用Python里面的base64来解一下不过这里注意一个问题,这个字符串里面%3D%3D base64没法解,但是去掉就会报错:binascii.Error: Incorrect padding 这个问题只需要把 %3D 换成 = 就行了 用户名中可能包含@这样的符号，解码之后@变成了%40 &gt;&gt;&gt; import base64 &gt;&gt;&gt; base64.b64decode(&quot;MTQ3MzAxODY3MSU0MHFxLmNvbQ==&quot;) # %3D 就是 = 两个%3D 就是== b&apos;1473018671%40qq.com&apos; # %40就是 @ &gt;&gt;&gt; 看见没，和咱们输入的帐号一样~ 得到预登录参数咱们已经知道prelogin.php的请求里的su参数是怎么生成的了~所以就只需要把url里面的su参数改一下就可以拿到预登录的数据~接着用浏览器打开刚才抓到的prelogin.php?请求的url,他返回的是: sinaSSOController.preloginCallBack({&quot;retcode&quot;:0,&quot;servertime&quot;:1508233777,&quot;pcid&quot;:&quot;gz-074aaac89dd6886019ebc121f0137b79ec17&quot;,&quot;nonce&quot;:&quot;AFJHZY&quot;,&quot;pubkey&quot;:&quot;EB2A38568661887FA180BDDB5CABD5F21C7BFD59C090CB2D245A87AC253062882729293E5506350508E7F9AA3BB77F4333231490F915F6D63C55FE2F08A49B353F444AD3993CACC02DB784ABBB8E42A9B1BBFFFB38BE18D78E87A0E41B9B8F73A928EE0CCEE1F6739884B9777E4FE9E88A1BBE495927AC4A799B3181D6442443&quot;,&quot;rsakv&quot;:&quot;1330428213&quot;,&quot;is_openlock&quot;:0,&quot;showpin&quot;:0,&quot;exectime&quot;:88}) 这里面我们需要拿4个参数,servertime nonce pubkey rsakv 输入帐号密码，登录现在找一下他的POST参数~接着抓包~在抓包前，先打开preserve log，不然就一闪而过，抓不到了~当输入帐号密码登录之后~你会看见一个login.php?的请求 https://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19) 这个url是一个POST，我们可以拿到他POST出去的数据参数，就是Form Data里面的东西有些参数是不是很眼熟呀？～～ su: 用户名，咱们用base64可以搞出来 servertime: 服务器时间，通过预登录得到 nonce: 通过预登录得到 rsakv: 通过预登录得到 sp: 密码,通过rsa加密,这个东西在ssologin.js里面,稍后介绍~ 其他参数保持不变~ 加密密码在login.php?client=ssologin.js(v1.4.19) 下面有一个ssologin.js顺便看一下home?wvr=5&amp;lf=reg我们后面会用到~ 长达2000多行~~在900行左右你会看见…… 是吧！我们得到这个东西 var RSAKey = new sinaSSOEncoder.RSAKey(); RSAKey.setPublic(me.rsaPubkey, &quot;10001&quot;); password = RSAKey.encrypt([me.servertime, me.nonce].join(&quot;\\t&quot;) + &quot;\\n&quot; + password) 加密方法~他有两种加密方法~就看RSA就行了~注意一下 &#39;10001&#39; 需要转换成十进制就是 65537 上代码！需要用到的模块: import urllib import urllib.request import urllib.parse import base64 import rsa import json import http.cookiejar import binascii import re from bs4 import BeautifulSoup 需要安装的模块: pip install rsa pip install bs4 初始化初始化username 和 password 12345class WeiboLogin(): def __init__(self,username,password): self.username = username self.password = password Cookie建立一个cookies，用于登录过程的cookies绑定~ 123456789def enableCookies(self): # 建立一个cookies 容器 cookie_container = http.cookiejar.CookieJar() # 将一个cookies容器和一个HTTP的cookie的处理器绑定 cookie_support = urllib.request.HTTPCookieProcessor(cookie_container) # 创建一个opener,设置一个handler用于处理http的url打开 opener = urllib.request.build_opener(cookie_support, urllib.request.HTTPHandler) # 安装opener，此后调用urlopen()时会使用安装过的opener对象 urllib.request.install_opener(opener) 加密用户名解码之后@变成了%40,如果帐号的纯数字的，会出现%3D,对应为=加密之前必须先把username字符串转化成url的编码样式，实现这一功能的是urllib.request.qoutebase64编码是bytes的形式，但是我们需要得到str,才能被接受 1234def getusername(self): username_req_qo = urllib.request.quote(self.username) username_bsencode = base64.b64encode(bytes(username_req_qo,encoding=&apos;utf-8&apos;)) return username_bsencode.decode(&quot;utf-8&quot;).split(&quot;=&quot;)[0] 获取4个参数12345678910111213def getprelogin(self): prelogin_url = &quot;https://login.sina.com.cn/sso/prelogin.php?entry=weibo&amp;callback=sinaSSOController.preloginCallBack&amp;su=&#123;&#125;&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.19)&amp;_=1507974787556&quot;.format(self.getusername()) pre = re.compile(&apos;sinaSSOController.preloginCallBack(.*)&apos;) request = urllib.request.Request(prelogin_url) response = urllib.request.urlopen(request) read_data = response.read().decode(&quot;utf-8&quot;) date = pre.search(read_data).group(1)[1:-1] date_json = json.loads(date) servertime = str(date_json[&apos;servertime&apos;]) nonce = date_json[&apos;nonce&apos;] pubkey = date_json[&apos;pubkey&apos;] rsakv = date_json[&apos;rsakv&apos;] return servertime,nonce,pubkey,rsakv 加密密码上面说过了&#39;10001&#39; 需要转换成十进制就是 65537 12345678def getpassword(self): servertime,nonce,pubkey,rsakv = self.getprelogin() pw_string = str(servertime) + &apos;\\t&apos; + str(nonce) + &apos;\\n&apos; + str(self.password) key = rsa.PublicKey(int(pubkey,16),65537) # 10001 == 65537 转10进制 pw_encrypt = rsa.encrypt(pw_string.encode(&apos;utf-8&apos;),key) self.password = &apos;&apos; # 安全起见~清空密码~ passwd = binascii.b2a_hex(pw_encrypt) return passwd POST1234567891011121314151617181920212223242526def build_post_data(self): servertime, nonce, pubkey, rsakv = self.getprelogin() post_data = &#123; &apos;entry&apos;: &apos;weibo&apos;, &apos;gateway&apos;: &apos;1&apos;, &apos;from&apos;: &apos;&apos;, &apos;savestate&apos;: &apos;7&apos;, &apos;qrcode_flag&apos;: &apos;false&apos;, &apos;useticket&apos;: &apos;1&apos;, &quot;pagerefer&quot;:&quot;http://passport.weibo.com/visitor/visitor?entry=miniblog&amp;a=enter&amp;url=http%3A%2F%2Fweibo.com%2F&amp;domain=.weibo.com&amp;ua=php-sso_sdk_client-0.6.14&quot;, &apos;vsnf&apos;: &apos;1&apos;, &apos;su&apos;: self.getusername(), &apos;service&apos;:&apos;miniblog&apos;, &apos;servertime&apos;: servertime, &apos;nonce&apos;: nonce, &apos;pwencode&apos;: &apos;rsa2&apos;, &apos;rsakv&apos;: rsakv, &apos;sp&apos;: self.getpassword(), &apos;sr&apos;: &apos;1920 * 1080&apos;, &apos;ncoding&apos;: &apos;UTF - 8&apos;, &apos;prelt&apos;: &apos;912&apos;, &apos;url&apos;: &quot;http://weibo.com/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack&quot;, &apos;returntype&apos;: &apos;META&apos; &#125; data = urllib.parse.urlencode(post_data).encode(&apos;utf-8&apos;) return data 登录123456789def login(self): url = &apos;https://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19)&apos; data = self.build_post_data() self.enableCookies() headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36&quot;&#125; requests1 = urllib.request.Request(url,data=data,headers=headers) reqopen1 = urllib.request.urlopen(requests1) reqread1 = reqopen1.read().decode(&quot;GBK&quot;) print(reqread1) 到这一步登录之后，恶心的重定向出现了….. 返回的内容: &lt;html&gt; &lt;head&gt; &lt;title&gt;新浪通行证&lt;/title&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=&amp;#39;https://login.sina.com.cn/crossdomain2.php?action=login&amp;entry=weibo&amp;r=https%3A%2F%2Fpassport.weibo.com%2Fwbsso%2Flogin%3Fssosavestate%3D1539793002%26url%3Dhttp%253A%252F%252Fweibo.com%252Fajaxlogin.php%253Fframelogin%253D1%2526callback%253Dparent.sinaSSOController.feedBackUrlCallBack%26ticket%3DST-NTUxMzA4ODA3Mw%3D%3D-1508257002-gz-755E02FA479243D1D971FC7697414B96-1%26retcode%3D0&amp;sr=1920+%2A+1080&amp;#39;&quot;/&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=GBK&quot; /&gt; &lt;/head&gt; &lt;body bgcolor=&quot;#ffffff&quot; text=&quot;#000000&quot; link=&quot;#0000cc&quot; vlink=&quot;#551a8b&quot; alink=&quot;#ff0000&quot;&gt; &lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt; location.replace(&quot;https://login.sina.com.cn/crossdomain2.php?action=login&amp;entry=weibo&amp;r=https%3A%2F%2Fpassport.weibo.com%2Fwbsso%2Flogin%3Fssosavestate%3D1539793002%26url%3Dhttp%253A%252F%252Fweibo.com%252Fajaxlogin.php%253Fframelogin%253D1%2526callback%253Dparent.sinaSSOController.feedBackUrlCallBack%26ticket%3DST-NTUxMzA4ODA3Mw%3D%3D-1508257002-gz-755E02FA479243D1D971FC7697414B96-1%26retcode%3D0&amp;sr=1920+%2A+1080&quot;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 重定向的url写在 location.replace的后面可以用正则，可以用bs4或者你觉得有更好的方法 更改一下，我用bs4 12345678910111213141516def login(self): url = &apos;https://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19)&apos; data = self.build_post_data() self.enableCookies() headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36&quot;&#125; requests1 = urllib.request.Request(url,data=data,headers=headers) reqopen1 = urllib.request.urlopen(requests1) reqread1 = reqopen1.read().decode(&quot;GBK&quot;) bs = BeautifulSoup(reqread1,&apos;lxml&apos;) bfind = bs.find(&apos;script&apos;) for i in bfind: p = i.strip().split(&apos;&quot;&apos;)[1] requests2 = urllib.request.Request(p) reqopen2 = urllib.request.urlopen(requests2) reqread2 = reqopen2.read() print(reqread2) 然后…. b&apos;&lt;html&gt;\\n&lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=GBK&quot; /&gt;\\n&lt;title&gt;\\xd0\\xc2\\xc0\\xcb\\xcd\\xa8\\xd0\\xd0\\xd6\\xa4&lt;/title&gt;\\n\\n\\n&lt;script charset=&quot;utf-8&quot; src=&quot;https://i.sso.sina.com.cn/js/ssologin.js&quot;&gt;&lt;/script&gt;\\n&lt;/head&gt;\\n&lt;body&gt;\\n\\xd5\\xfd\\xd4\\xda\\xb5\\xc7\\xc2\\xbc ...\\n&lt;script&gt;\\ntry{sinaSSOController.setCrossDomainUrlList({&quot;retcode&quot;:0,&quot;arrURL&quot;:[&quot;https:\\\\/\\\\/passport.weibo.com\\\\/wbsso\\\\/login?ticket=ST-NTUxMzA4ODA3Mw%3D%3D-1508257418-gz-1D704A04699B6A20EFE6F4123E677198-1&amp;ssosavestate=1539793417&quot;,&quot;https:\\\\/\\\\/passport.97973.com\\\\/sso\\\\/crossdomain?action=login&amp;savestate=1539793417&quot;,&quot;https:\\\\/\\\\/passport.weibo.cn\\\\/sso\\\\/crossdomain?action=login&amp;savestate=1&quot;]});}\\n\\t\\tcatch(e){\\n\\t\\t\\tvar msg = e.message;\\n\\t\\t\\tvar img = new Image();\\n\\t\\t\\tvar type = 1;\\n\\t\\t\\timg.src = \\&apos;https://login.sina.com.cn/sso/debuglog?msg=\\&apos; + msg +\\&apos;&amp;type=\\&apos; + type;\\n\\t\\t}try{sinaSSOController.crossDomainAction(\\&apos;login\\&apos;,function(){location.replace(\\&apos;https://passport.weibo.com/wbsso/login?ssosavestate=1539793417&amp;url=http%3A%2F%2Fweibo.com%2Fajaxlogin.php%3Fframelogin%3D1%26callback%3Dparent.sinaSSOController.feedBackUrlCallBack&amp;ticket=ST-NTUxMzA4ODA3Mw==-1508257417-gz-64BE9EFA64E07479B7DB6F8882CA661C-1&amp;retcode=0\\&apos;);});}\\n\\t\\tcatch(e){\\n\\t\\t\\tvar msg = e.message;\\n\\t\\t\\tvar img = new Image();\\n\\t\\t\\tvar type = 2;\\n\\t\\t\\timg.src = \\&apos;https://login.sina.com.cn/sso/debuglog?msg=\\&apos; + msg +\\&apos;&amp;type=\\&apos; + type;\\n\\t\\t}\\n&lt;/script&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;&apos; 又是一个重定向…….好嘞~bs4不好抓了~用正则吧~ 123456789101112131415161718192021222324252627def login(self): url = &apos;https://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19)&apos; data = self.build_post_data() self.enableCookies() headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36&quot;&#125; requests1 = urllib.request.Request(url,data=data,headers=headers) reqopen1 = urllib.request.urlopen(requests1) reqread1 = reqopen1.read().decode(&quot;GBK&quot;) bs = BeautifulSoup(reqread1,&apos;lxml&apos;) bfind = bs.find(&apos;script&apos;) for i in bfind: p = i.strip().split(&apos;&quot;&apos;)[1] requests2 = urllib.request.Request(p) reqopen2 = urllib.request.urlopen(requests2) reqread2 = reqopen2.read() bss = BeautifulSoup(reqread2,&apos;lxml&apos;) bff = bss.find_all(&apos;script&apos;)[1] try: p2 = re.compile(r&apos;location.replace(.*?);&#125;&apos;) for i in bff: get_p2 = p2.findall(i)[0][2:-2] requests3 = urllib.request.Request(get_p2) reqopen3 = urllib.request.urlopen(requests3) reqread3 = reqopen3.read().decode(&apos;utf-8&apos;) print(reqread3) except IndexError: print(&quot;Login Error!&quot;) 返回结果: 12/usr/bin/python3.5 /home/crazyrookie/Documents/Python/reptile/weibo_login.py&lt;html&gt;&lt;head&gt;&lt;script language=&apos;javascript&apos;&gt;parent.sinaSSOController.feedBackUrlCallBack(&#123;&quot;result&quot;:true,&quot;userinfo&quot;:&#123;&quot;uniqueid&quot;:&quot;5513088073&quot;,&quot;userid&quot;:null,&quot;displayname&quot;:null,&quot;userdomain&quot;:&quot;?wvr=5&amp;lf=reg&quot;&#125;&#125;);&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 又是一个重定向…….但是注意到里面有个?wvr=5&amp;lf=reg字段，看看刚才手工登陆抓到的包，就是我让各位顺便看一下的那个地方,这是是主页链接的一部分。再写一个正则,把?wvr=5&amp;lf=reg拼接一个url出来，就可以轻松而愉悦地模拟登陆了！ 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import urllibimport urllib.requestimport urllib.parseimport base64import rsaimport jsonimport http.cookiejarimport binasciiimport refrom bs4 import BeautifulSoupclass WeiboLogin(): def __init__(self,username,password): self.username = username self.password = password def enableCookies(self): # 建立一个cookies 容器 cookie_container = http.cookiejar.CookieJar() # 将一个cookies容器和一个HTTP的cookie的处理器绑定 cookie_support = urllib.request.HTTPCookieProcessor(cookie_container) # 创建一个opener,设置一个handler用于处理http的url打开 opener = urllib.request.build_opener(cookie_support, urllib.request.HTTPHandler) # 安装opener，此后调用urlopen()时会使用安装过的opener对象 urllib.request.install_opener(opener) # 加密用户名 def getusername(self): username_req_qo = urllib.request.quote(self.username) username_bsencode = base64.b64encode(bytes(username_req_qo,encoding=&apos;utf-8&apos;)) return username_bsencode.decode(&quot;utf-8&quot;).split(&quot;=&quot;)[0] # 得到servertime,nonce,pubkey,rsakv # 输入用户名和密码之后（不登录）会出现一个prologin的预登陆的包 def getprelogin(self): prelogin_url = &quot;https://login.sina.com.cn/sso/prelogin.php?entry=weibo&amp;callback=sinaSSOController.preloginCallBack&amp;su=&#123;&#125;&amp;rsakt=mod&amp;checkpin=1&amp;client=ssologin.js(v1.4.19)&amp;_=1507974787556&quot;.format(self.getusername()) pre = re.compile(&apos;sinaSSOController.preloginCallBack(.*)&apos;) request = urllib.request.Request(prelogin_url) response = urllib.request.urlopen(request) read_data = response.read().decode(&quot;utf-8&quot;) date = pre.search(read_data).group(1)[1:-1] date_json = json.loads(date) servertime = str(date_json[&apos;servertime&apos;]) nonce = date_json[&apos;nonce&apos;] pubkey = date_json[&apos;pubkey&apos;] rsakv = date_json[&apos;rsakv&apos;] return servertime,nonce,pubkey,rsakv # 加密密码 def getpassword(self): servertime,nonce,pubkey,rsakv = self.getprelogin() pw_string = str(servertime) + &apos;\\t&apos; + str(nonce) + &apos;\\n&apos; + str(self.password) key = rsa.PublicKey(int(pubkey,16),65537) # 10001 == 65537 转10进制 pw_encrypt = rsa.encrypt(pw_string.encode(&apos;utf-8&apos;),key) self.password = &apos;&apos; # 安全起见~清空密码~ passwd = binascii.b2a_hex(pw_encrypt) return passwd # POST参数 def build_post_data(self): servertime, nonce, pubkey, rsakv = self.getprelogin() post_data = &#123; &apos;entry&apos;: &apos;weibo&apos;, &apos;gateway&apos;: &apos;1&apos;, &apos;from&apos;: &apos;&apos;, &apos;savestate&apos;: &apos;7&apos;, &apos;qrcode_flag&apos;: &apos;false&apos;, &apos;useticket&apos;: &apos;1&apos;, &quot;pagerefer&quot;:&quot;http://passport.weibo.com/visitor/visitor?entry=miniblog&amp;a=enter&amp;url=http%3A%2F%2Fweibo.com%2F&amp;domain=.weibo.com&amp;ua=php-sso_sdk_client-0.6.14&quot;, &apos;vsnf&apos;: &apos;1&apos;, &apos;su&apos;: self.getusername(), &apos;service&apos;:&apos;miniblog&apos;, &apos;servertime&apos;: servertime, &apos;nonce&apos;: nonce, &apos;pwencode&apos;: &apos;rsa2&apos;, &apos;rsakv&apos;: rsakv, &apos;sp&apos;: self.getpassword(), &apos;sr&apos;: &apos;1920 * 1080&apos;, &apos;ncoding&apos;: &apos;UTF - 8&apos;, &apos;prelt&apos;: &apos;912&apos;, &apos;url&apos;: &quot;http://weibo.com/ajaxlogin.php?framelogin=1&amp;callback=parent.sinaSSOController.feedBackUrlCallBack&quot;, &apos;returntype&apos;: &apos;META&apos; &#125; data = urllib.parse.urlencode(post_data).encode(&apos;utf-8&apos;) return data def login(self): url = &apos;https://login.sina.com.cn/sso/login.php?client=ssologin.js(v1.4.19)&apos; data = self.build_post_data() self.enableCookies() headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/61.0.3163.100 Safari/537.36&quot;&#125; requests1 = urllib.request.Request(url,data=data,headers=headers) reqopen1 = urllib.request.urlopen(requests1) reqread1 = reqopen1.read().decode(&quot;GBK&quot;) bs = BeautifulSoup(reqread1,&apos;lxml&apos;) bfind = bs.find(&apos;script&apos;) for i in bfind: p = i.strip().split(&apos;&quot;&apos;)[1] requests2 = urllib.request.Request(p) reqopen2 = urllib.request.urlopen(requests2) reqread2 = reqopen2.read() bss = BeautifulSoup(reqread2,&apos;lxml&apos;) bff = bss.find_all(&apos;script&apos;)[1] try: p2 = re.compile(r&apos;location.replace(.*?);&#125;&apos;) p3 = re.compile(r&apos;&quot;userdomain&quot;:&quot;(.*?)&quot;&apos;) for i in bff: get_p2 = p2.findall(i)[0][2:-2] requests3 = urllib.request.Request(get_p2) reqopen3 = urllib.request.urlopen(requests3) reqread3 = reqopen3.read().decode(&apos;utf-8&apos;) userdomain = p3.findall(reqread3) login_url = &apos;http://weibo.com/&apos; + userdomain[0] requests4 = urllib.request.Request(login_url) reqopen4 = urllib.request.urlopen(requests4) reqread4 = reqopen4.read().decode(&apos;utf-8&apos;) bs_date = BeautifulSoup(reqread4,&apos;lxml&apos;) bfind_nick_uid = bs_date.find_all(&apos;script&apos;) nick_re = re.compile(&quot;CONFIG\\[&apos;nick&apos;\\]=&apos;.*?&apos;;&quot;) uin_re = re.compile(&quot;CONFIG\\[&apos;uid&apos;\\]=&apos;.*?&apos;;&quot;) for i in bfind_nick_uid[2]: print(&quot;Login success!&quot;) print(&quot;Usernmae:&quot;,nick_re.search(i.strip()).group().split(&apos;=&apos;)[1][1:-2],&quot;Uin:&quot;,uin_re.search(i).group().split(&apos;=&apos;)[1][1:-2]) except IndexError: print(&quot;Login Error!&quot;)if __name__ == &apos;__main__&apos;: w = WeiboLogin(&apos;&apos;,&apos;&apos;) w.login() 结果如下: Login success! Usernmae: 呆呆的设计师 Uin: 5513088073 到此结束,如果发现有啥地方不对劲或者没理解的地方可以在下面的评论区写下~Thanks~","path":"2017/10/18/weibo-login/","date":"10-18","excerpt":"在无声的世界里，默默地等待着他的出现 ----《声之形》 大概有两个月左右没更新过文章了，没想到还会有人来参观这个博客～访问人数在逐渐增加，这一点我挺开心的～最近也挺忙的……开学了不说～我还报了驾校，也快考科目一了，练习倒库练了一个礼拜，前一个小时倒进去没啥问题的，过了几个小时后又进不去了…….唉。行～废话也不多说，这次我介绍一下如何用Python来登录新浪微博~","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://liuyangxiong.cn/tags/Python爬虫/"}]},{"title":"爬取网易云音乐歌单里的所有歌曲歌词及评论并保存到数据库","text":"无论在哪里遇到你，我都会喜欢上你. ---《angel beats》 难度不大~就介绍几个网易云音乐的API吧~ 获取歌单 http://music.163.com/api/v3/playlist/detail? 获取评论 http://music.163.com/api/v1/resource/comments/R_SO_4_ 获取歌词 http://music.163.com/api/song/lyric?id=&amp;lv=-1&amp;kv=-1&amp;tv=-1 获取歌曲 http://music.163.com/song? 我这里就给这几个了~更多的API上网搜一下就有了~ 我是用MySQL来存储的,用下面的这条命令来安装 pip install pymysql 然后里面的数据除了id,其他我都是拿base64处理过再放进数据库的,不然某些字符会报错~ 因为难度不大，返回的都是json~我这里就直接给我写好的源代码了~不过要注意的是，一定要加代理，不然ip会被封的~我感受过~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167import requestsfrom bs4 import BeautifulSoupimport numpy as npimport timeimport osimport base64import pymysqlclass Wangyiyunyinyue(): def __init__(self,user,password,db,url): self.connent_sql = pymysql.connect(user=&apos;&#123;&#125;&apos;.format(user), password=&quot;&#123;&#125;&quot;.format(password), host=&quot;127.0.0.1&quot;, port=3306, db=&quot;&#123;&#125;&quot;.format(db)) self.cursor = self.connent_sql.cursor() self.headers = &#123; &quot;Accept&quot;:&quot;*/*&quot;, &quot;Connection&quot;:&quot;keep-alive&quot;, &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&quot; &#125; self.proxies = &#123;&apos;https&apos;:&apos;https://61.183.176.122&apos;,&apos;https&apos;:&apos;https://121.32.122.37&apos;&#125; self.url = url def sql(self): sql = &quot;&quot;&quot; CREATE TABLE IF NOT EXISTS song_information( playlist_id VARCHAR(20), song_id VARCHAR(20), singer VARCHAR(200), song_name VARCHAR(200), alium VARCHAR(200), lyric VARCHAR(30) ); CREATE TABLE IF NOT EXISTS comment_text( song_id VARCHAR(20), userId VARCHAR(20), nickname VARCHAR(100), comment TEXT ); &quot;&quot;&quot; data = &quot;show tables;&quot; self.cursor.execute(data) check = self.cursor.fetchall() if check == (): print(&quot;正在创建数据表.....&quot;) print(&quot;数据表创建成功！！！&quot;) print(&quot;---------------------------&quot;) self.cursor.execute(sql) self.connent_sql.commit() else: pass def song_sql(self,playlist_id,song_id,singer,song_name,alium,lyric): data = &quot;INSERT INTO song_information (playlist_id,song_id,singer,song_name,alium,lyric) VALUES (&apos;&#123;&#125;&apos;,&apos;&#123;&#125;&apos;,&apos;&#123;&#125;&apos;,&apos;&#123;&#125;&apos;,&apos;&#123;&#125;&apos;,&apos;&#123;&#125;&apos;)&quot;.format(playlist_id,song_id,singer,song_name,alium,lyric) self.cursor.execute(data) self.connent_sql.commit() def comment_sql(self,song_id,userid,nickname,comment): data = &quot;INSERT INTO comment_text (song_id,userId,nickname,comment) VALUES (&apos;&#123;&#125;&apos;,&apos;&#123;&#125;&apos;,&apos;&#123;&#125;&apos;,&apos;&#123;&#125;&apos;)&quot;.format(song_id,userid,nickname,comment) self.cursor.execute(data) self.connent_sql.commit() def check_sql(self): date = &quot;SELECT comment_text.comment FROM song_information,comment_text WHERE song_information.song_id=comment_text.song_id and song_information.song_id=3423803&quot; # date = &quot;SELECT * FROM song_information;&quot; self.cursor.execute(date) results = self.cursor.fetchall() # print(a) x = 1 for i in results: # print(x,i[0],base64.b64decode(str.encode(i[1])).decode(&quot;utf-8&quot;),base64.b64decode(str.encode(i[-1])).decode(&quot;utf-8&quot;)) # print(x,&quot;userid:&quot;,base64.b64decode(str.encode(i[2])).decode(&quot;utf-8&quot;),&quot;内容:&quot;,base64.b64decode(str.encode(i[-1])).decode(&quot;utf-8&quot;)) # print(x,base64.b64decode(str.encode(i[2])).decode(&quot;utf-8&quot;)) print(x,base64.b64decode(str.encode(i[0])).decode(&quot;utf-8&quot;)) x+=1 def song(self,id): song_url = &quot;http://music.163.com/song?id=&#123;&#125;&quot;.format(id) ressong = requests.get(song_url,headers=self.headers,proxies=self.proxies,timeout=10) Bs = BeautifulSoup(ressong.text,&apos;lxml&apos;) song_name = Bs.find(&quot;div&quot;,class_=&quot;cnt&quot;).find_all(&quot;div&quot;,class_=&quot;tit&quot;) singer_and_alium = Bs.find(&quot;div&quot;,class_=&quot;cnt&quot;).find_all(&apos;p&apos;) song_information = [] for sn in song_name: song_information.append(base64.b64encode(str.encode(sn.get_text().strip()))) for sa in singer_and_alium: song_information.append(base64.b64encode(str.encode(sa.get_text().split(&quot;：&quot;)[1]))) try: print(&quot;歌曲:&quot;,base64.b64decode(song_information[0]).decode(&quot;utf-8&quot;), &quot;歌手:&quot;,base64.b64decode(song_information[1]).decode(&quot;utf-8&quot;), &quot;专辑:&quot;,base64.b64decode(song_information[2]).decode(&quot;utf-8&quot;)) self.song_sql(self.url.split(&quot;=&quot;)[-1],id,song_information[1].decode(&quot;utf-8&quot;),song_information[0].decode(&quot;utf-8&quot;),song_information[2].decode(&quot;utf-8&quot;),&quot;lyric/&#123;&#125;/&#123;&#125;.lrc&quot;.format(self.url.split(&quot;=&quot;)[-1],id)) except KeyError: pass except UnicodeEncodeError: print(&quot;GBK&quot;) # windows下 GBK错误~ def lyric(self,id): lyric_url = &quot;http://music.163.com/api/song/lyric?id=&#123;&#125;&amp;lv=-1&amp;kv=-1&amp;tv=-1&quot;.format(id) reslyric = requests.get(lyric_url,headers=self.headers,proxies=self.proxies,timeout=10) sp_url = self.url.split(&quot;=&quot;)[-1] try: English_lyric = reslyric.json()[&apos;lrc&apos;][&apos;lyric&apos;] Chinese_lyric = reslyric.json()[&apos;tlyric&apos;][&apos;lyric&apos;] with open(&quot;lyric/&#123;&#125;/&#123;&#125;.lrc&quot;.format(sp_url,id),&apos;a&apos;) as w: w.write(English_lyric) w.write(Chinese_lyric) except KeyError: #没有歌词的会报错! pass except TypeError: pass # 有些歌词，要么只有英文,要么只有中文，要么连歌词都没有~~~:) except UnicodeEncodeError: # windows下 GBK错误~ pass def comment(self,id): comment_url = &quot;http://music.163.com/api/v1/resource/comments/R_SO_4_&#123;&#125;&quot;.format(id) rescomment = requests.get(comment_url,headers=self.headers,proxies=self.proxies,timeout=10) for cm in range(len(rescomment.json()[&apos;hotComments&apos;])): userid = rescomment.json()[&apos;hotComments&apos;][cm][&apos;user&apos;][&apos;userId&apos;] nickname = rescomment.json()[&apos;hotComments&apos;][cm][&apos;user&apos;][&apos;nickname&apos;] comment = rescomment.json()[&apos;hotComments&apos;][cm][&apos;content&apos;] self.comment_sql(id,userid,base64.b64encode(str.encode(nickname)).decode(&quot;utf-8&quot;),base64.b64encode(str.encode(comment)).decode(&quot;utf-8&quot;)) def main(self): playlist_url = &quot;http://music.163.com/api/v3/playlist/detail?id=&#123;&#125;&quot;.format(self.url.split(&quot;=&quot;)[-1]) reslist = requests.get(playlist_url,headers=self.headers,proxies=self.proxies,timeout=10) if reslist.json()[&apos;code&apos;] == 404: print(&quot;URL 地址不对嘛~ -_-!!&quot;) else: self.sql() print(&quot;正在检测歌单id &apos;&#123;&#125;&apos; 是否在数据库中......&quot;.format(self.url.split(&quot;=&quot;)[-1])) data = &quot;SELECT playlist_id FROM song_information WHERE playlist_id=&#123;&#125; LIMIT 1;&quot;.format(self.url.split(&quot;=&quot;)[-1]) self.cursor.execute(data) se = self.cursor.fetchall() if se != (): print(&quot;---------------------------&quot;) print(&quot;这个歌单已经在数据库了~请重新换一个歌单~~&quot;) else: if os.path.exists(&quot;lyric&quot;) == False: os.mkdir(&quot;lyric&quot;) if os.path.exists(&quot;lyric/&#123;&#125;&quot;.format(self.url.split(&quot;=&quot;)[-1])) == False: os.mkdir(&quot;lyric/&#123;&#125;&quot;.format(self.url.split(&quot;=&quot;)[-1])) print(&quot;开始抓取~~~~&quot;) for ids in reslist.json()[&apos;playlist&apos;][&apos;trackIds&apos;]: time.sleep(np.random.random()) self.song(ids[&apos;id&apos;]) self.lyric(ids[&apos;id&apos;]) self.comment(ids[&apos;id&apos;])if __name__ == &quot;__main__&quot;: url=&quot;&quot; # 填入歌单的url地址~比如:http://music.163.com/#/playlist?id=864401021 user=&quot;&quot; # MySQL账号 root password=&quot;&quot; # MySQL密码 db=&quot;&quot; # 数据库名称 if url == &quot;&quot;: print(&quot;你url地址还没输呐~~&quot;) else: try: w = Wangyiyunyinyue(user,password,db,url) w.main() except pymysql.err.OperationalError: print(&quot;连接失败~请检查数据库(MySQL)账号或密码是否正确~~~&quot;) 效果: 有问题就在下面的评论区说~~github: 源代码","path":"2017/08/21/wangyiyunyinyue/","date":"08-21","excerpt":"无论在哪里遇到你，我都会喜欢上你. ---《angel beats》 难度不大~就介绍几个网易云音乐的API吧~","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://liuyangxiong.cn/tags/Python爬虫/"}]},{"title":"利用cookie爬取QQ空间留言板","text":"也许我所失去的，正是我生命中绝不该放手的东西。---《云之彼端，约定的地方》 拿代码直接登陆QQ空间有点复杂~说实话我不会~所以就拿cookie来登陆，cookie这东西很重要，他包含用户的重要信息~ 因为要用cookie登陆，咱们就先去看看cookie~打开QQ空间登陆页面，然后打开开发者工具~接着打开Network进行捕捉~登陆上之后，一般捕捉到的第一个里面就包含着登陆的cookie如下图 红框框里的就是我账号的登陆cookie咱们开头也说了,这东西很重要，你原封不动的拿过去，服务器也是承认你已经登陆了，对于登陆用户，能干的事情就多了….. 接着，保持开发者工具不动，打开留言板找到以get_msgb开头的~如下图~ 点开他，观察一下~ 红框框里面的就是咱们要的东西~他在data下的commentList里面,接着点开commentList nickname 就是给你留言的名字 pubtime 是留言时间 uin 是对方的QQ号 htmlContent 是留言的内容 ubbContent 也是留言的内容 htmlContent和ubbContent同样是留言内容，不过通过变量名就能猜出了~htmlContent应该是处理过的ubbContent是原始的，要选哪一个呐？ 咱们选ubbContent,为啥？仔细看看就知道了~~ OK~来查看一下Headers里面的链接~复制这个链接用浏览器打开看一下~和咱们在开发者工具里面内容一样 接下来就派出蜘蛛吧~ 12345678910111213141516import requestsimport jsonimport numpyimport timecookie = &quot;welcomeflash=1473018671_15; ...................................&quot;header = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&apos;,&apos;Connection&apos;: &apos;keep-alive&apos;,&apos;accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,&apos;Cookie&apos;: cookie&#125;proxies = &#123;&apos;http&apos;:&apos;http://27.185.194.55:8118&apos;&#125;url = &quot;https://h5.qzone.qq.com/proxy/domain/m.qzone.qq.com/cgi-bin/new/get_msgb?uin=1473018671&amp;hostUin=1473018671&amp;start=0&amp;s=0.6099869503510162&amp;format=jsonp&amp;num=10&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;g_tk=1911197127&amp;qzonetoken=40006667030cbf36e52d4a80e349d674e7024da4780b92a66c3f5f3b9e413903b691aac1b0d294bfbe&quot;res = requests.get(url,proxies=proxies,headers=header)print(res.text) 代码里面我的cookie我去掉了~url地址也是拿自己的～从开发者工具上复制就行了~ 运行一下: 没问题~和刚才打开的内容一样~不过现在弄下来的是一个字符串~不能直接json先用切片把_Callback()去掉~ 12345678910111213cookie = &quot;welcomeflash=1473018671_15; ............................&quot;header = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&apos;,&apos;Connection&apos;: &apos;keep-alive&apos;,&apos;accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,&apos;Cookie&apos;: cookie&#125;proxies = &#123;&apos;http&apos;:&apos;http://27.185.194.55:8118&apos;&#125;url = &quot;https://h5.qzone.qq.com/proxy/domain/m.qzone.qq.com/cgi-bin/new/get_msgb?uin=1473018671&amp;hostUin=1473018671&amp;start=0&amp;s=0.6099869503510162&amp;format=jsonp&amp;num=10&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;g_tk=1911197127&amp;qzonetoken=40006667030cbf36e52d4a80e349d674e7024da4780b92a66c3f5f3b9e413903b691aac1b0d294bfbe&quot;res = requests.get(url,proxies=proxies,headers=header)get_text = res.text[10:-3]js = json.loads(get_text)for i in range(len(js[&apos;data&apos;][&apos;commentList&apos;])): print(js[&apos;data&apos;][&apos;commentList&apos;][i][&apos;nickname&apos;],&apos;\\t&apos;,js[&apos;data&apos;][&apos;commentList&apos;][i][&apos;ubbContent&apos;]) 成啦~这一页没问题~下一页咋办呐？~ 继续观察开发者工具点击下一页~ 看一下这个链接和上一个的链接有啥变化~~ 在这个链接里面，咱们就只需要修改两个地方~一个是start另一个是s的参数 start是0、10、20、30、40、50、60……这样一直上去的,用个while循环进行了s是随机的时间,可以用random.random或者numpy.random.random实现,两个都一样,我就用第二个吧~ 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsimport jsonimport numpyimport timecookie = &quot;&quot; # 输入自己的 cookieheader = &#123;&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36&apos;,&apos;Connection&apos;: &apos;keep-alive&apos;,&apos;accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,&apos;Cookie&apos;: cookie&#125;proxies = &#123;&apos;http&apos;:&apos;http://27.185.194.55:8118&apos;&#125;times = 0uin = input(&quot;QQ帐号: &quot;)print(&quot;请注意更改url中qzonetoken和g_tk参数&quot;)if cookie == &quot;&quot;: print(&quot;请输入cookie!&quot;)else: while True: print(&quot;第 &#123;&#125; 页&quot;.format(((times//10)+1))) print(&quot;----------------------------------------&quot;) url = &quot;https://h5.qzone.qq.com/proxy/domain/m.qzone.qq.com/cgi-bin/new/get_msgb?uin=&#123;&#125;&amp;hostUin=&#123;&#125;&amp;num=10&amp;start=&#123;&#125;&amp;hostword=0&amp;essence=1&amp;s=&#123;&#125;&amp;iNotice=0&amp;inCharset=utf-8&amp;outCharset=utf-8&amp;format=jsonp&amp;ref=qzone&amp;g_tk=159637896&amp;qzonetoken=2a26403b960220332f267c6736eec1e4053e1f6eb5791eb2fe314429eb084741d2f4b70466ac0e7f1c&quot;.format(uin,uin,str(times),numpy.random.random()) # url地址要自己去开发者工具里面拿~上面的这个是我自己的~复制自己的修改一下就行了~ regs = requests.get(url, proxies=proxies, headers=header) str_qiepian = regs.text[10:-3] try: js = json.loads(str_qiepian)[&apos;data&apos;][&apos;commentList&apos;] except KeyError: print(&quot;请更换cookie!&quot;) break except json.decoder.JSONDecodeError: print(&quot;请更换url地址，地址中的qzonetoken验证和g_tk有变&quot;) break if js == []: print(&quot;Over! 共计 &#123;&#125; 页&quot;.format(json.loads(str_qiepian)[&apos;data&apos;][&apos;total&apos;])) break else: for page in range(len(js)): print(&quot;第&#123;&#125;页的第&#123;&#125;条 留言者:&#123;&#125; \\t 内容:&#123;&#125;&quot;.format((times//10)+1,page+1,js[page][&apos;nickname&apos;],js[page][&apos;ubbContent&apos;])) times+=10 time.sleep(numpy.random.random()) 注意啊！修改自己的cookie和urlurl只需要更改qzonetoken和g_tk参数 效果: 就到这儿吧~有问题请在下面评论区留言~~各位大佬手下留情~源代码:爬取QQ空间留言板","path":"2017/08/12/qq-strip-message/","date":"08-12","excerpt":"也许我所失去的，正是我生命中绝不该放手的东西。---《云之彼端，约定的地方》 拿代码直接登陆QQ空间有点复杂~说实话我不会~所以就拿cookie来登陆，cookie这东西很重要，他包含用户的重要信息~","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://liuyangxiong.cn/tags/Python爬虫/"}]},{"title":"用最简单的方法爬《煎蛋》","text":"说残酷的谎言会受到惩罚的。------《Re：从零开始的异世界生活》 那啥~开头本来想说点气势较大的话的~可实在想不出来该说点啥~算了~直接发教程吧~ 煎蛋网址: http://jandan.net/ 用到模块: urllib BeautifulSoup lxml 安装方式: 因为urllib是自带的，就不用下载了·~ pip install bs4 pip install lxml ok,安装完成之后~就开始吧~ 咱们就搞下面这三个就行了~其他的没啥可看的~ 首先来妹子图吧~ 看一下图片的地址在哪儿，指着图片右键~点检查,如下图 能看见有两个链接~第一个是原图的~第二个是处理过的~咱们肯定要原图的~接着,找一下这个页面的所有图片 发现他是用无序列表ol~~上代码: 1234567891011import urllib.requestfrom bs4 import BeautifulSoupheaders = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;&#125;ooxx_url = &quot;http://jandan.net/ooxx&quot;Requesturl = urllib.request.Request(ooxx_url,headers=headers)openurl = urllib.request.urlopen(Requesturl)Be = BeautifulSoup(openurl.read().decode(&apos;utf-8&apos;),&apos;lxml&apos;)ooxx_image_url = Be.find(&quot;ol&quot;,class_=&quot;commentlist&quot;).find_all(&apos;a&apos;,class_=&quot;view_img_link&quot;)for x in ooxx_image_url: print(&quot;http:&quot;+x[&apos;href&apos;]) 上面的代码就可以返回妹子图的地址啦~ ![jiandanjiandan_7.png]https://i.loli.net/2018/12/23/5c1f5182936c7.png) 虽然就可以直接这样下载下来的，但是呐~下载下来的图片得有名字呐~接着爬，把发布人的名字和图片的ID也搞下来~继续观察网页源代码~ 如上图~发布人的名字和图片ID就在这里~也好搞~ 123456789101112import urllib.requestfrom bs4 import BeautifulSoupheaders = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;&#125;ooxx_url = &quot;http://jandan.net/ooxx&quot;Requesturl = urllib.request.Request(ooxx_url,headers=headers)openurl = urllib.request.urlopen(Requesturl)Be = BeautifulSoup(openurl.read().decode(&apos;utf-8&apos;),&apos;lxml&apos;)issue_name = Be.find(&apos;ol&apos;,class_=&quot;commentlist&quot;).find_all(&quot;strong&quot;)content_id = Be.find(&apos;ol&apos;,class_=&quot;commentlist&quot;).find_all(&quot;span&quot;,class_=&quot;righttext&quot;)for x in zip(issue_name,content_id): print(x[0].get_text(),x[1].get_text()) 行了~现在可以弄下来了~~但是呐~还有一个问题~他的页码是从最大的数往下的~继续看网页源代码… 1234567891011import urllib.requestfrom bs4 import BeautifulSoupheaders = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;&#125;url = &quot;http://jandan.net/ooxx&quot;Requesturl = urllib.request.Request(url,headers=headers)reopen = urllib.request.urlopen(Requesturl)Be = BeautifulSoup(reopen.read().decode(&quot;utf-8&quot;),&apos;lxml&apos;)BeSoup = Be.find(&quot;span&quot;,class_=&quot;current-comment-page&quot;)for Bs in BeSoup: print(str(Bs)[1:-1]) 上面的代码就是可以返回页码~ 行啦~可以搞下来了~接下来搞无聊图….但是~妹子图的源码和无聊图的是一样的~~~只需要改一下url就行了~这里就不重复搞了~直接上段子 发现段子也和妹子图的一样… 12345678910import urllib.requestfrom bs4 import BeautifulSoupduan_url = &quot;http://jandan.net/duan&quot;Requesturl = urllib.request.Request(duan_url,headers=headers)reopen = urllib.request.urlopen(Requesturl)Be = BeautifulSoup(reopen.read().decode(&quot;utf-8&quot;),&apos;lxml&apos;)BeSoup = duan_text = Be.find(&apos;ol&apos;,class_=&quot;commentlist&quot;).find_all(&quot;p&quot;)for Bs in BeSoup: print(Bs.get_text()) ok了….是不是很简单~这样就出来啦~整理一下~~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import urllib.requestfrom bs4 import BeautifulSoupimport shutilimport osclass Ooxx(): def __init__(self,url): self.headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36&quot;&#125; self.url = url def check_folter(self): if os.path.exists(self.url) == True: shutil.rmtree(self.url) os.mkdir(self.url) else: os.mkdir(self.url) def get_page(self): Requesturl = urllib.request.Request(&quot;http://jandan.net/&quot;+self.url,headers=self.headers) reopen = urllib.request.urlopen(Requesturl) Be = BeautifulSoup(reopen.read().decode(&quot;utf-8&quot;),&apos;lxml&apos;) BeSoup = Be.find(&quot;span&quot;,class_=&quot;current-comment-page&quot;) for Bs in BeSoup: return str(Bs)[1:-1] def dowload(self): self.check_folter() if select_user == &quot;1&quot; or select_user == &quot;2&quot;: page = int(self.get_page()) while page: print(&quot;````````````````````````````````````````````````````&quot;) print(&quot;正在下载第 &#123;&#125; 页&quot;.format(page)) url = &quot;http://jandan.net/&#123;&#125;/page-&#123;&#125;#comments&quot;.format(self.url,page) Requesturl = urllib.request.Request(url,headers=self.headers) reopen = urllib.request.urlopen(Requesturl) Be = BeautifulSoup(reopen.read().decode(&quot;utf-8&quot;),&apos;lxml&apos;) ooxx_image_url = Be.find(&quot;ol&quot;,class_=&quot;commentlist&quot;).find_all(&apos;a&apos;,class_=&quot;view_img_link&quot;) issue_name = Be.find(&apos;ol&apos;,class_=&quot;commentlist&quot;).find_all(&quot;strong&quot;) content_id = Be.find(&apos;ol&apos;,class_=&quot;commentlist&quot;).find_all(&quot;span&quot;,class_=&quot;righttext&quot;) for dowload in zip(ooxx_image_url,issue_name,content_id): print(&quot;作者:&#123;&#125; 图片ID:&#123;&#125; 地址:&#123;&#125; OK!&quot;.format(dowload[1].get_text(),dowload[2].get_text(),&quot;http:&quot;+dowload[0][&apos;href&apos;])) urllib.request.urlretrieve(&quot;http:&quot;+dowload[0][&apos;href&apos;],&quot;&#123;&#125;/&#123;&#125;&quot;.format(self.url,dowload[1].get_text()+dowload[2].get_text()+dowload[0][&apos;href&apos;][-4:])) print(&quot;第 &#123;&#125; 页下载完成!&quot;.format(page)) page-=1 elif select_user == &quot;3&quot;: page = int(self.get_page()) while page: print(&quot;````````````````````````````````````````````````````&quot;) print(&quot;正在下载第 &#123;&#125; 页&quot;.format(page)) url = &quot;http://jandan.net/&#123;&#125;/page-&#123;&#125;#comments&quot;.format(self.url,page) Requesturl = urllib.request.Request(url,headers=self.headers) reopen = urllib.request.urlopen(Requesturl) Be = BeautifulSoup(reopen.read().decode(&quot;utf-8&quot;),&apos;lxml&apos;) duan_text = Be.find(&apos;ol&apos;,class_=&quot;commentlist&quot;).find_all(&quot;p&quot;) issue_name = Be.find(&apos;ol&apos;,class_=&quot;commentlist&quot;).find_all(&quot;strong&quot;) content_id = Be.find(&apos;ol&apos;,class_=&quot;commentlist&quot;).find_all(&quot;span&quot;,class_=&quot;righttext&quot;) for dowload in zip(duan_text,issue_name,content_id): print(&quot;\\n作者:&#123;&#125; ID:&#123;&#125; 内容:&#123;&#125; OK!&quot;.format(dowload[1].get_text(),dowload[2].get_text(),dowload[0].get_text())) try: with open(&quot;&#123;&#125;/&#123;&#125;&quot;.format(self.url,dowload[1].get_text()+dowload[2].get_text()+&quot;.txt&quot;),&apos;w&apos;) as save: save.write(dowload[0].get_text()) except UnicodeEncodeError: pass print(&quot;第 &#123;&#125; 页下载完成!&quot;.format(page)) page-=1if __name__ == &apos;__main__&apos;: select_user = input(&quot;&gt;&gt;&gt; &quot;) if select_user == &quot;1&quot;: x = Ooxx(&quot;ooxx&quot;) x.dowload() elif select_user == &quot;2&quot;: x = Ooxx(&quot;pic&quot;) x.dowload() elif select_user == &quot;3&quot;: x = Ooxx(&quot;duan&quot;) x.dowload() else: print(&quot;Srroy,not &#123;&#125;&quot;.format(select_user)) 我在测试的时候，无聊写了一个GUI的爬虫~里面包括了煎蛋~斗图啦~百思不得姐的内容写完之后自我感觉挺好哒~源代码 看看也行~~ 但是在Linux只能打开，没法爬取呐…不知道啥问题~目前只能在Windows下运行~ 就这些~有问题请在下面的评论区反馈~~","path":"2017/07/26/jiandan-reptile/","date":"07-26","excerpt":"说残酷的谎言会受到惩罚的。------《Re：从零开始的异世界生活》 那啥~开头本来想说点气势较大的话的~可实在想不出来该说点啥~算了~直接发教程吧~","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://liuyangxiong.cn/tags/Python爬虫/"}]},{"title":"啥？破解WIFI密码这么容易？","text":"吾于冥河沉浮,受尽命运捉弄，纵然汝将忘吾，吾亦伴汝身旁。 ---《Re：从零开始的异世界生活》 黑客是很多人崇拜的，黑客技术也是很多人想学的，想入侵一下网站啊～往仇人家的电脑丢病毒等等的啊～但成功的人也并不多，因为需要的知识甚多。今天我头一次接触这个领域，从来没有玩过，成功的那一秒我是多兴奋哒～像中了大奖似的，这次就给大佬们送上aircrack-ng工具的使用方法～ 在开始之前，请确保是Linux系统然后安装一个工具，本来就是介绍这个工具的使用方法的～在终端里输入下面这条命令下载 sudo apt-get install aircrack-ng 第一步:查看无线网卡是否正常了连接: sudo iwconfig 通过上面的命令就可以知道无线网卡的名字了，我的是wlp3s0第二步:把无线网卡改为monitor监听模式 sudo airmon-ng start wlp3s0 再输入一次 sudo iwconfig 发现网卡名字改变了,我的变成了wlp3s0mon第三步:抓取无线数据包激活无线网卡后，就可以使用Aircrack-ng套装里的工具来实现了~先来看看当前无线网络概况，包括AP的SSID、MAC地址、工作频道、无线客户端MAC及数量等~~打开一个Shell输入: sudo airodump-ng wlp3s0mon 回车后~就能看到类似于下图的～ 以上输出的信息显示了附近所有可用的无线网络。当找到用户想要攻击的无线路由器时，按下Ctrl+C键停止搜索～ BSSID：无线的IP地址 PWR：网卡报告的信号水平 Beacons：无线发出的通告编号 Data：被捕获到的数据分组的数量，包括广播分组 /s：过去10秒钟内每秒捕获数据分组的数量 CH：信道号 MB：无线所支持的最大速率 ENC：使用的加密算法体系 CIPHER：检测到的加密算法 AUTH：使用的认证协议 ESSID：指所谓的SSID号。如果启用隐藏的SSID的话，它可以为空 STATION：客户端的MAC地址，包括连上的和想要搜索无线来连接的客户端 Rate：表示传输率 Lost：在过去10秒钟内丢失的数据分组，基于序列号检测 Frames：客户端发送的数据分组数量 Probe：被客* 户端查探的ESSID 接着输入: sudo airodump-ng -c 1 -w hello wlp3s0mon 解释一下:-c 这里我们设置目标AP的工作频道,就是上图中的CH-w 后跟要保存的文件名回车后~看见下图就说明无线数据包抓取已经开始～接下来保持这个窗口不动，注意，不要把它关闭了。另外打开一个Shell。进行后面的内容～ 第四步:进行Deauth攻击加速破解过程~打开新的Shll输入: aireplay-ng -0 1 –a AP的mac -c 客户端的mac wlp3s0mon 解释:-0 采用deauth攻击模式，后面跟上攻击次数，可以根据实际情况设置为10不等；-a 后跟AP的MAC地址-c 后跟客户端的MAC地址如下图，根据自己的更改 和破解WEP时不同，这里为了获得破解所需的WPA-PSK握手验证的整个完整数据包如果是WEP的话就输入: aireplay-ng -3 -b AP的mac -h 客户端的mac wlp3s0mon 解释:-3 指采用ARPRequesr注入攻击模式；-b 后跟AP的MAC地址-h 后跟客户端的MAC地址回车后将会看到deauth报文发送的数据:此时回到airodump-ng的界面查看，在右上角出现了“WPA handshake”的提示，这表示获得到了包含WPA-PSK密码的4此握手数据报文，至于后面是目标AP的MAC，这里的AP指的就是要破解的无线路由器。就是图中红框框里面的 如果没有上面，那么可以增加Deauth的发送数量，再一次对目标AP进行攻击，把-0 后面的参数该为10～第五步:开始破解! sudo aircrack-ng -w dict 捕捉到的cap文件 解释:-w 后跟预先制作的字典接下来就要耐心的等待了～可以去喝杯咖啡～～ 在“KEY FOUND”提示的右侧，可以看到密码已被破解出,其实主要还是靠字典和电脑性能，aircrack-ng只是一个工具～破解WPA-PSK对硬件要求及字典要求很高，所以只要你多准备一些常用的字典比如生日、8位数字等，这样破解的时候也会增大破解的成功率～～第六步:恢复正常模式 sudo airmon-ng stop wlp3s0mon sudo service network-manager start 输入以上命令就可以恢复正常的上网模式～","path":"2017/06/24/aircrack-ng-wifi/","date":"06-24","excerpt":"吾于冥河沉浮,受尽命运捉弄，纵然汝将忘吾，吾亦伴汝身旁。 ---《Re：从零开始的异世界生活》 黑客是很多人崇拜的，黑客技术也是很多人想学的，想入侵一下网站啊～往仇人家的电脑丢病毒等等的啊～但成功的人也并不多，因为需要的知识甚多。今天我头一次接触这个领域，从来没有玩过，成功的那一秒我是多兴奋哒～像中了大奖似的，这次就给大佬们送上aircrack-ng工具的使用方法～","tags":[{"name":"WIFI","slug":"WIFI","permalink":"https://liuyangxiong.cn/tags/WIFI/"}]},{"title":"python3 打造GUI个性签名生成器","text":"我能想起来的一直都是你的背影 ————四月是您的谎言 好久没发点啥了～最近在忙着学习前端呢~这次就发点好玩哒~用python3打造GUI个性签名的生成器~ 咱们先来看一下效果~ 看着还行吧～～Python版本是3.5的~ 首先，咱们先把界面写出来～～ 123456789101112from tkinter import *MainWindows = Tk()MainWindows.geometry(&quot;400x250&quot;)MainWindows.maxsize(&quot;400&quot;,&quot;250&quot;)MainWindows.minsize(&quot;400&quot;,&quot;250&quot;)MainWindows.title(&quot;个性签名&quot;)MainWindows.config(bg=&quot;#444&quot;)Label(MainWindows,text=&quot;姓名: &quot;,font=(&quot;楷体&quot;,20),bg=&quot;#444&quot;,fg=&quot;#fff&quot;).place(x=50,y=50)names = Entry(MainWindows,font=(&quot;楷体&quot;,20),fg=&quot;#666&quot;,width=15)names.place(x=140,y=50)Button(MainWindows,text=&quot;一键设计&quot;,font=(&quot;楷体&quot;,15),relief=&quot;solid&quot;).place(x=280,y=200)MainWindows.mainloop() 现在已经可以输入名字了，但是怎么把图片搞过来呢？ 去看一看网页http://www.uustv.com/ 打开开发者工具，先随便输入一个，看一看啥样的~~ 在我点击马上给我设计之后,有两个gif,第二个是我们想要的图片～～ 接着,咱们看一下第一个 最后面这个就是我们输入文字点击view soure,显示本来的面目: word=%E6%88%91%E7%88%B1%E4%B8%AD%E5%9B%BD&amp;sizes=60&amp;fonts=jfcs.ttf&amp;fontcolor=%23000000看看英文意思就明白了，word的就是我们输入的文字，被浏览器处理过了～我们改就要改这里图片就更好弄了,点击Preview 这就是返回的图片，拼接地址就是:http://www.uustv.com/tmp/149597716941200.gif但是直接在浏览器上访问是打不开的～～ OK,现在怎么拿到图片也知道了，上代码 12345678import urllib.requestimport reurl = &quot;http://www.uustv.com/&quot;html_Request = urllib.request.Request(url,data=&quot;word=&#123;&#125;&amp;sizes=60&amp;fonts=jfcs.ttf&amp;fontcolor=%23000000&quot;.format(&quot;我爱中国&quot;).encode( &quot;utf-8&quot;))html_open = urllib.request.urlopen(html_Request).read().decode(&quot;utf-8&quot;)res = &apos;&lt;div class=&quot;tu&quot;&gt; &lt;img src=&quot;(.*?)&quot;/&gt;&lt;/div&gt;&apos;re_html = re.findall(res, html_open)print(re_html) 这个会返回一个list,[‘tmp/149597780094792.gif’]，没问题,现在把它们放在一起就ok了 12345678910111213141516171819202122232425262728293031323334import urllib.requestimport refrom tkinter import *from tkinter import messageboxfrom PIL import Imagedef get_name(): name = names.get() if not name: messagebox.showinfo(title=&quot;提示&quot;,message=&quot;姓名不得为空&quot;) else: url = &quot;http://www.uustv.com/&quot; html_Request = urllib.request.Request(url,data=&quot;word=&#123;&#125;&amp;sizes=60&amp;fonts=jfcs.ttf&amp;fontcolor=%23000000&quot;.format(name).encode(&quot;utf-8&quot;)) html_open = urllib.request.urlopen(html_Request).read().decode(&quot;utf-8&quot;) res = &apos;&lt;div class=&quot;tu&quot;&gt; &lt;img src=&quot;(.*?)&quot;/&gt;&lt;/div&gt;&apos; re_html = re.findall(res,html_open) urllib.request.urlretrieve(url+re_html[0],&quot;%s.gif&quot; % name) try: open_img = Image.open(&quot;%s.gif&quot; % name) open_img.show() open_img.close() except : messagebox.showinfo(title=&quot;提示&quot;,message=&quot;请自行打开!&quot;)if __name__ == &apos;__main__&apos;: MainWindows = Tk() MainWindows.geometry(&quot;400x250&quot;) MainWindows.maxsize(&quot;400&quot;,&quot;250&quot;) MainWindows.minsize(&quot;400&quot;,&quot;250&quot;) MainWindows.title(&quot;个性签名&quot;) MainWindows.config(bg=&quot;#444&quot;) Label(MainWindows,text=&quot;姓名: &quot;,font=(&quot;楷体&quot;,20),bg=&quot;#444&quot;,fg=&quot;#fff&quot;).place(x=50,y=50) names = Entry(MainWindows,font=(&quot;楷体&quot;,20),fg=&quot;#666&quot;,width=15) names.place(x=140,y=50) Button(MainWindows,text=&quot;一键设计&quot;,font=(&quot;楷体&quot;,15),relief=&quot;solid&quot;,command=get_name).place(x=280,y=200) MainWindows.mainloop() 2017年 05月 29日 星期一 17点有人要求把剩下的六种字体也写上，按照他的要求，还是加上了,其实很容易的，把data数据的fonts的值改成对应的字体就行了～～直接上代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import urllib.requestimport refrom tkinter import *from tkinter import messageboxfrom PIL import Imagedef downloading(name,var): url = &quot;http://www.uustv.com/&quot; html_Request = urllib.request.Request(url,data=&quot;word=&#123;&#125;&amp;sizes=60&amp;fonts=&#123;&#125;&amp;fontcolor=%23000000&quot;.format(name,var).encode(&quot;utf-8&quot;)) html_open = urllib.request.urlopen(html_Request).read().decode(&quot;utf-8&quot;) res = &apos;&lt;div class=&quot;tu&quot;&gt; &lt;img src=&quot;(.*?)&quot;/&gt;&lt;/div&gt;&apos; re_html = re.findall(res,html_open) urllib.request.urlretrieve(url+re_html[0],&quot;%s.gif&quot; % name) try: open_img = Image.open(&quot;%s.gif&quot; % name) open_img.show() open_img.close() except : messagebox.showinfo(title=&quot;提示&quot;,message=&quot;请自行打开!&quot;)def get_name(): name = names.get() select_var = var.get() signature_ttf = [&quot;jfcs.ttf&quot;,&quot;qmt.ttf&quot;,&quot;bzcs.ttf&quot;,&quot;lfc.ttf&quot;,&quot;haku.ttf&quot;,&quot;zql.ttf&quot;,&quot;yqk.ttf&quot;] if not name: messagebox.showinfo(title=&quot;提示&quot;,message=&quot;姓名不得为空!&quot;) elif select_var == 1: downloading(name,signature_ttf[0]) elif select_var == 2: downloading(name,signature_ttf[1]) elif select_var == 3: downloading(name,signature_ttf[2]) elif select_var == 4: downloading(name,signature_ttf[3]) elif select_var == 5: downloading(name,signature_ttf[4]) elif select_var == 6: downloading(name,signature_ttf[5]) elif select_var == 7: downloading(name,signature_ttf[6]) else: messagebox.showinfo(title=&quot;提示&quot;,message=&quot;请选择您想要的样式!&quot;)if __name__ == &apos;__main__&apos;: MainWindows = Tk() MainWindows.geometry(&quot;400x250&quot;) MainWindows.maxsize(&quot;400&quot;,&quot;250&quot;) MainWindows.minsize(&quot;400&quot;,&quot;250&quot;) MainWindows.title(&quot;个性签名&quot;) MainWindows.config(bg=&quot;#444&quot;) Label(MainWindows,text=&quot;姓名: &quot;,font=(&quot;楷体&quot;,20),bg=&quot;#444&quot;,fg=&quot;#fff&quot;).place(x=50,y=50) names = Entry(MainWindows,font=(&quot;楷体&quot;,20),fg=&quot;#666&quot;,width=15) names.place(x=140,y=50) var = IntVar() rb1 = Radiobutton(MainWindows,text=&quot;个性签&quot;,variable=var,value=1,bg=&quot;#444&quot;,relief=&quot;solid&quot;).place(x=50,y=115) rb2 = Radiobutton(MainWindows,text=&quot;连笔签&quot;,variable=var,value=2,bg=&quot;#444&quot;,relief=&quot;solid&quot;).place(x=50,y=150) rb3 = Radiobutton(MainWindows,text=&quot;潇洒签&quot;,variable=var,value=3,bg=&quot;#444&quot;,relief=&quot;solid&quot;).place(x=50,y=185) rb4 = Radiobutton(MainWindows,text=&quot;草体签&quot;,variable=var,value=4,bg=&quot;#444&quot;,relief=&quot;solid&quot;).place(x=50,y=220) rb5 = Radiobutton(MainWindows,text=&quot;合文签&quot;,variable=var,value=5,bg=&quot;#444&quot;,relief=&quot;solid&quot;).place(x=150,y=115) rb6 = Radiobutton(MainWindows,text=&quot;商务签&quot;,variable=var,value=6,bg=&quot;#444&quot;,relief=&quot;solid&quot;).place(x=150,y=150) rb7 = Radiobutton(MainWindows,text=&quot;可爱签&quot;,variable=var,value=7,bg=&quot;#444&quot;,relief=&quot;solid&quot;).place(x=150,y=185) Button(MainWindows,text=&quot;一键设计&quot;,font=(&quot;楷体&quot;,15),relief=&quot;solid&quot;,command=get_name).place(x=280,y=200) MainWindows.mainloop() 效果: 很简单吧～源代码如果出现问题,请在下面评论~~ 更新:源代码 修复窗口未响应的假死状态","path":"2017/05/28/signature/","date":"05-28","excerpt":"我能想起来的一直都是你的背影 ————四月是您的谎言 好久没发点啥了～最近在忙着学习前端呢~这次就发点好玩哒~用python3打造GUI个性签名的生成器~","tags":[{"name":"PythonGUI","slug":"PythonGUI","permalink":"https://liuyangxiong.cn/tags/PythonGUI/"}]},{"title":"猜数字游戏2.0 升级版(数据保存)","text":"猫是可爱的，狼是很帅的。就是说，孤独又可爱又帅。 ————大老师引用了大老师的话，嘿嘿～我最喜爱的动漫角色就是”大老师”，我也是动漫迷嘛～小萝莉太棒了！——咳咳～这篇本来打算过年的时候就发的(没网)，加上这几天没时间，所以给忘了，这个程序是我在过年的时候无聊写的，因为实在是闲得扣脚…除了吃就是睡，主要还没网(农村嘛～)，补上补上～～～ 还记得以前我写的那个猜数字小游戏吗？Guess_number1.0 还有那个可以登录注册找回密码的登录太简单了,运行一次玩一次，没意思,第二次数据就没了，后来在过年中无聊的我稍稍考虑了一下，反正也没事干，稍微改改,增加点东西吧,对了~我用的是python3.5写的。文件说明 主程序: Guess_number2.0.py(文件夹)game_date: 用来存储玩家信息的(文件夹)root_date: 主要原来存储管理员信息user_date.txt: 存储玩家的登录信息（名字和密码）user_mail.txt: 存储玩家的信息（名字和邮箱）root.txt: 存储管理员的信息（名字和密码），除了root，所有管理员的信息也会存储到user_date.txtroot_mail.txt: 存储管理员的信息(名字和邮箱)date.txt: 存储用户的登录时间注册时间退出时间游戏时间 上面的文件就自己创建了(都必须要有，少一个都不行!)全部文件就是这个效果： 因为我们要从数据库（文本文件）里面拿东西,用的是json，如果文本文件里面没有内容，json是会报错的，这个问题以后修复！所以重要的一点：要预先在user_date.txt root.txt中写入 {“root”: “aef2cda059e51bd364c7140bdc7ac956”} user_mail.txt root_mail.txt 中写入 {“root”: “root123@qq.com”} 直接复制进去就行了,你也可以自己更改然后呢,默认的超级管理员帐号和密码就是 账号:root 密码：root123 邮箱：root123@qq.com 功能 实现用户的登录,注册,找回密码,密码是加密过的猜数字游戏(简单，普通，困难)三种模式管理员模式(超级root,管理员),root可创建新的管理员,管理员可删除玩家可将数据保持到本地，下次也可以使用~不需要再重新注册 还有好多….因为太长时间了….我就不一一解释怎么写出来的了，代码共计700多行左右,很容易的,相信有基础的一看就明白是怎么回事了，我基本都写了注释,如果实在是看不懂,评论留言吧，看见了我会回复的.直接上代码! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750# -*- coding: utf-8 -*-import jsonimport hashlibimport osimport getpassfrom random import randintimport reimport time# 加密密码def hasd_md5(user,password): md5 = hashlib.md5() md5.update((user+password+&quot;Guess*Number&quot;).encode()) return md5.hexdigest()# 查看游戏的历史记录def cat_game_history(name): with open(&quot;game_date/&quot;+name+&quot;.txt&quot;,&apos;r&apos;) as cat_file: if os.name == &quot;posix&quot;: os.system(&quot;gedit game_date/&#123;&#125;.txt&quot;.format(name)) else: print(cat_file.read())# 登录系统class Register: # 注册 def register(self): print(&quot;--------------&quot;) print(&quot;| ~注册界面~ |&quot;) print(&quot;--------------&quot;) with open(&quot;user_date.txt&quot;,&apos;r&apos;) as u: # 获取本地文本文件里的用户数据(用户名和密码) user_name = json.load(u) with open(&quot;user_mail.txt&quot;) as m: # 同上，获取本地用户的用户名和邮箱(两个都是dict) user_main = json.load(m) while True: print(&quot;输入q可退出注册&quot;) get_mail = [i for i in user_main.values()] # 得到邮箱 new_name = input(&quot;New name: &quot;) if new_name == &quot;q&quot; or new_name == &quot;Q&quot;: print(&quot;已取消注册!&quot;) Re = Register() Re.Login() break new_password = getpass.getpass(&quot;New Password: &quot;) again_password = getpass.getpass(&quot;Again Password:&quot;) new_mail = input(&quot;Mail: &quot;) password_chack = [i for i in new_password if i.isalpha()] # 检查密码里面有没有带字母，没有就是[]空list mail_split = new_mail.split(&quot;@&quot;) # 将邮箱拆成两半 mail_re = re.findall(r&apos;[^a-z0-9]+&apos;,mail_split[0]) # 匹配,有数字和字母都ok,其他都不要 if len(new_name.split()) != 1 or (new_name.strip() == new_name) == False: # 用户名中不能有空格 print(&quot;用户名中不能包含空格&quot;) elif new_password != again_password: # 判断两次的密码是否相同 print(&quot;两次密码不相同,请重新输入!&quot;) continue elif new_name in user_name: # 检查 新的用户名有没有在本地数据库中 print(&quot;用户名已经存在！&quot;) continue elif len(new_password) &lt;= 6 or password_chack == []: # 密码长度不能小于6位数，并且至少有一个字母 print(&quot;密码太弱，请输入6位数以上且至少有1一个字母&quot;) elif new_mail in get_mail: # 检查 邮箱有没有被注册 print(&quot;&apos;%s&apos; 邮箱已被注册！&quot; % new_mail) elif mail_re != [] or mail_split[-1] not in [&quot;qq.com&quot;,&quot;gmail.com&quot;,&quot;163.com&quot;]: #检查 用户输入的邮箱格式 print(&quot;请输入正确的邮箱&quot;) else: get_user_md5 = hasd_md5(new_name, new_password) user_name[new_name] = get_user_md5 # 数据库里面的都是dict user_main[new_name] = new_mail with open(&quot;user_date.txt&quot;,&apos;w&apos;) as f: json.dump(user_name,f) # 重新写入本地数据库 if os.name == &quot;posix&quot;: os.system(r&quot;echo &gt; game_date/&#123;&#125;.txt&quot;.format(new_name)) # 在注册成功的同时将用户的Game数据创建了～ else: open(&quot;game_date/&#123;&#125;.txt&quot;.format(new_name),&apos;w&apos;) print(&quot;%s 创建成功！&quot; % new_name) with open(&quot;date.txt&quot;,&apos;a&apos;) as d: d.write(&quot;\\n--------------------------------------------------------------------------\\n&quot;) d.write(&quot;北京时间:&#123;&#125; 用户&#123;&#125;加入了这里&quot;.format(time.ctime(),new_name)) d.write(&quot;\\n--------------------------------------------------------------------------\\n\\n&quot;) with open(&quot;game_date/&quot;+new_name+&quot;.txt&quot;,&apos;w&apos;) as f: f.write(&quot;----------------------------------------------------------------------------\\n&quot;) f.write(&quot;亲爱的&apos;&#123;&#125;&apos;,欢迎您加入!\\n&quot;.format(new_name)) f.write(&quot;注册时间: &quot;) f.write(time.ctime()) f.write(&quot;\\n---------------------------------------------------------------------------\\n\\n\\n&quot;) with open(&quot;user_mail.txt&quot;,&apos;w&apos;) as s: json.dump(user_main,s) return &quot;A&quot; # 这里返回A是为了注册完后可以直接登录 break # 找回密码 def Find_password(self): print(&quot;--------------&quot;) print(&quot;| ～找回密码～ |&quot;) print(&quot;--------------&quot;) with open(&quot;user_mail.txt&quot;,&apos;r&apos;) as f: user_mail = json.load(f) with open(&quot;user_date.txt&quot;,&apos;r&apos;) as d: user_name = json.load(d) with open(&quot;root_mail.txt&quot;,&apos;r&apos;) as rm: root_mail = json.load(rm) with open(&quot;root.txt&quot;,&apos;r&apos;) as r: roots = json.load(r) while True: name = input(&quot;user name: &quot;) mail = input(&quot;Mail: &quot;) if name in roots and mail == root_mail[name]: while True: New_password = getpass.getpass(&quot;New Password: &quot;) again_password = getpass.getpass(&quot;Again Password: &quot;) get_new_md5 = hasd_md5(name, New_password) # 得到新的md5值 if New_password == again_password: user_name[name] = get_new_md5 print(&quot;修改成功！&quot;) with open(&quot;user_date.txt&quot;,&apos;w&apos;) as n: # 将新的数据写入数据库 json.dump(user_name,n) with open(&quot;root.txt&quot;,&apos;w&apos;) as rs: json.dump(user_name,rs) break else: print(&quot;两次密码不相同!&quot;) break elif name in user_name and mail == user_mail[name]: # 判断用户名和邮箱和数据库的合不合 while True: New_password = getpass.getpass(&quot;New Password: &quot;) again_password = getpass.getpass(&quot;Again Password: &quot;) get_new_md5 = hasd_md5(name, New_password) # 得到新的md5值 if New_password == again_password: user_name[name] = get_new_md5 print(&quot;修改成功！&quot;) with open(&quot;user_date.txt&quot;,&apos;w&apos;) as n: # 将新的数据写入数据库 json.dump(user_name,n) break else: print(&quot;两次密码不相同!&quot;) break else: print(&quot;用户名或邮箱错误&quot;) # 主函数，登录 def Login(self): print(&quot;Login System!&quot;) print(&quot;--------------&quot;) print(&quot;| ~登录界面~ |&quot;) print(&quot;--------------&quot;) while True: print(&quot;任意键继续登录，输入&apos;q&apos;可取消登录&quot;) s = input(&quot;&gt;&gt;&gt; &quot;) if s == &quot;q&quot; or s == &quot;Q&quot;: print(&quot;已取消登录&quot;) break with open(&quot;user_date.txt&quot;,&apos;r&apos;) as u: # 获取用户的数据 user_date = json.load(u) name = input(&quot;User name: &quot;) password = getpass.getpass(&quot;password: &quot;) get_password_md5 = hasd_md5(name,password) if name not in user_date: print(&quot;用户名 %s 不存在！\\n 任意键继续注册,&apos;q&apos;退出&quot; % name) seleste = input(&quot;&gt;&gt;&gt; &quot;) # 退出注册！ if seleste == &quot;q&quot;: print(&quot;已退出!&quot;) Re = Register() Re.Login() break print(&quot;REGISTERED!&quot;) # 除了输入&apos;q&apos;以外的继续注册 Re = Register() Re.register() else: if name in user_date and user_date[name] == get_password_md5: # 判断用户输入的密码是否与数据库的相同 print(&quot;Welcome %s&quot; % name) with open(&quot;date.txt&quot;,&apos;a&apos;) as d: d.write(&quot;\\n\\n************************************************************\\n&quot;) d.write(&quot;北京时间:&#123;&#125;,用户&apos;&#123;&#125;&apos;登录游戏&quot;.format(time.ctime(),name)) d.write(&quot;\\n************************************************************\\n&quot;) print(&quot;亲爱的&apos;%s&apos;,欢迎您！&quot; % name) while True: print(&quot;------------------&quot;) print(&quot;-------菜单栏------&quot;) print(&quot;| 1.开始新游戏 |&quot;) print(&quot;| 2.查看历史记录 |&quot;) print(&quot;| 3.退出登录 |&quot;) user_input = input(&quot;1-2-3&quot;) if user_input == &quot;1&quot;: game = Game_date() game.main(name) stop() continue elif user_input == &quot;2&quot;: cat_game_history(name) stop() continue elif user_input == &quot;3&quot;: print(&quot;&#123;&#125;，已退出登录!&quot;.format(name)) with open(&quot;date.txt&quot;,&apos;a&apos;) as f: f.write(&quot;\\n\\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\n&quot;) f.write(&quot;北京时间:&#123;&#125;,用户&apos;&#123;&#125;&apos;退出了登录!&quot;.format(time.ctime(),name)) f.write(&quot;\\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\n&quot;) break else: print(&quot;抱歉，选项中没有 &apos;%s&apos;&quot; % user_input) continue break else: print(&quot;帐号或密码错误，是否找回密码？(y/n)&quot;) enter = str(input(&quot;&gt;&gt;&gt; &quot;)) if enter == &quot;Y&quot; or enter == &quot;y&quot;: #如果密码错误，可选择找回密码（重新设置） print(&quot;找回密码&quot;) Ref = Register() Ref.Find_password() else: continue# 游戏class Game_date: def main(self,name): print(&quot;Start Game!&quot;) print(&quot;----------------&quot;) print(&quot;| ~游戏界面~ |&quot;) print(&quot;----------------&quot;) print(&quot;请输入不大于20,不小于0的整数&quot;) cishu = 1 generate_list = [] # 存储用户输入的每一个数字 compute_total = &#123;&#125; # 存储用户输入的重复数字，比如 2 输入了两次就是&#123;&quot;2&quot;：2&#125; suijishu1 = randint(0,20) # 获取随机数 suijishu2 = randint(0,50) suijishu3 = randint(0,100) last_dict = &#123;&#125; # 存储最后重复过的总数,比如 2 最后所输入的6次,就是&#123;&quot;2&quot;:6&#125; get_list = [] # 得到输入的次数 print(&quot;选择难度: &quot;) print(&quot;````````````````&quot;) print(&quot;| 1.简单 |&quot;) print(&quot;| 2.一般 |&quot;) print(&quot;| 3.困难 |&quot;) print(&quot;````````````````&quot;) while True: user = input(&quot;&gt;&gt;&gt; &quot;) if user == &quot;1&quot;: print(&quot;~~~~~简单模式~~~~~&quot;) with open(&quot;date.txt&quot;,&apos;a&apos;) as d1: d1.write(&quot;\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n&quot;) d1.write(&quot;time:&#123;&#125;\\n&quot;.format(time.ctime())) d1.write(&quot;用户&apos;&#123;&#125;&apos;,进行 &#123;&#125; 的游戏&quot;.format(name,&quot;简单模式&quot;)) d1.write(&quot;\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n&quot;) break elif user == &quot;2&quot;: print(&quot;~~~~~一般模式~~~~~&quot;) with open(&quot;date.txt&quot;, &apos;a&apos;) as d2: d2.write(&quot;\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n&quot;) d2.write(&quot;time:&#123;&#125;\\n&quot;.format(time.ctime())) d2.write(&quot;用户&apos;&#123;&#125;&apos;,进行 &#123;&#125; 的游戏&quot;.format(name, &quot;一般模式&quot;)) d2.write(&quot;\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n&quot;) break elif user == &quot;3&quot;: print(&quot;~~~~~困难模式~~~~~&quot;) with open(&quot;date.txt&quot;,&apos;a&apos;) as d3: d3.write(&quot;\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n&quot;) d3.write(&quot;time:&#123;&#125;\\n&quot;.format(time.ctime())) d3.write(&quot;用户&apos;&#123;&#125;&apos;,进行 &#123;&#125; 的游戏&quot;.format(name,&quot;困难模式&quot;)) d3.write(&quot;\\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\n&quot;) break else: print(&quot;抱歉，没有&#123;&#125;&quot;.format(user)) continue print(&quot;Are you readr?&quot;) input(&quot;任意开始游戏！&quot;) print(&quot;Game Start!!!&quot;) start = time.time() while True: user_input = input(&quot;&gt;&gt;&gt; &quot;) generate_list.append(user_input) s = generate_list.count(user_input) compute_total[user_input]=s not_reast = set([i for i in generate_list if generate_list.count(i) &gt; 1]) # 没有重复的数字 get_num1 = [i for i in generate_list if i.strip() and i.isnumeric() and int(i) &lt; 21] # 只能有数字，其他的都不要～(难度1) get_num2 = [i for i in generate_list if i.strip() and i.isnumeric() and int(i) &lt; 51] # 同上，50以内(难度一般) get_num3 = [i for i in generate_list if i.strip() and i.isnumeric() and int(i) &lt; 101] # 100以内(难度困难) try: for i in not_reast: f = compute_total[i] get_list.append(f) last_dict[i]=get_list[-1] if user_input.isnumeric() == False: last_dict.pop(user_input) except KeyError: pass try: new_user = int(user_input) # except ValueError: compute_total.pop(user_input) print(&quot;请输入整数&quot;) cishu-1 continue if user == &quot;1&quot;: if new_user &gt; 20 or new_user &lt; 0: compute_total.pop(user_input) print(&quot;超过规定数额!&quot;) cishu-1 continue elif new_user &gt; suijishu1: print(&quot;太大了&quot;) elif new_user == suijishu1: try: last_dict.pop(&quot;&quot;) except KeyError: pass with open(&quot;game_date/&quot;+name+&quot;.txt&quot;,&apos;a&apos;) as f: end = time.time() times = &quot;共用时%0.2f秒\\n&quot; % (end-start) f.write(&quot;Game time:&#123;&#125;\\n&quot;.format(time.ctime())) print(&quot;猜对了！&quot;) print(times) f.write(times) a1 = &quot;共猜了&apos;&#123;&#125;&apos;次，此次您猜的数字共有&apos;&#123;&#125;\\n&quot;.format(cishu,get_num1) print(a1) f.write(a1) if not_reast == set(): a2 = &quot;没有重复的！\\n&quot; f.write(a2) f.write(&quot;__________________________________________________________________________________\\n\\n\\n&quot;) print(a2) break else: for i in zip(last_dict.items(),last_dict.values()): a3 = &quot; num:&apos;&#123;&#125;&apos;\\t重复&apos;&#123;&#125;&apos;次\\n&quot;.format(i[0][0],i[1]) f.write(a3) print(a3) a4 = &quot;去掉重复的，只算猜了&#123;&#125;次,只输入了&#123;&#125;\\n&quot;.format(len(set(get_num1)),set(get_num1)) f.write(a4) print(a4) f.write(&quot;__________________________________________________________________________________\\n\\n\\n&quot;) break elif new_user &lt; suijishu1: print(&quot;太小了&quot;) cishu+=1 elif user == &quot;2&quot;: if new_user &gt; 50 or new_user &lt; 0: compute_total.pop(user_input) print(&quot;超过规定数额!&quot;) cishu - 1 continue elif new_user &gt; suijishu2: print(&quot;太大了&quot;) elif new_user == suijishu2: try: last_dict.pop(&quot;&quot;) except KeyError: pass with open(&quot;game_date/&quot; + name + &quot;.txt&quot;, &apos;a&apos;) as f: end = time.time() times = &quot;共用时%0.2f秒\\n&quot; % (end-start) f.write(&quot;Game time:&#123;&#125;\\n&quot;.format(time.ctime())) f.write(times) print(&quot;猜对了！&quot;) print(times) a1 = &quot;共猜了&apos;&#123;&#125;&apos;次，此次您猜的数字共有&apos;&#123;&#125;\\n&quot;.format(cishu, get_num2) print(a1) f.write(a1) if not_reast == set(): a2 = &quot;没有重复的！\\n&quot; f.write(a2) f.write(&quot;__________________________________________________________________________________\\n\\n\\n&quot;) print(a2) break else: for i in zip(last_dict.items(), last_dict.values()): a3 = &quot; num:&apos;&#123;&#125;&apos;\\t重复&apos;&#123;&#125;&apos;次\\n&quot;.format(i[0][0], i[1]) f.write(a3) print(a3) a4 = &quot;去掉重复的，只算猜了&#123;&#125;次,只输入了&#123;&#125;\\n&quot;.format(len(set(get_num2)), set(get_num2)) f.write(a4) print(a4) f.write(&quot;__________________________________________________________________________________\\n\\n\\n&quot;) break elif new_user &lt; suijishu2: print(&quot;太小了&quot;) cishu += 1 elif user == &quot;3&quot;: if new_user &gt; 100 or new_user &lt; 0: compute_total.pop(user_input) print(&quot;超过规定数额!&quot;) cishu - 1 continue elif new_user &gt; suijishu3: print(&quot;太大了&quot;) elif new_user == suijishu3: try: last_dict.pop(&quot;&quot;) except KeyError: pass with open(&quot;game_date/&quot; + name + &quot;.txt&quot;, &apos;a&apos;) as f: end = time.time() times = &quot;共用时%0.2f秒\\n&quot; % (end-start) f.write(&quot;Game time:&#123;&#125;\\n&quot;.format(time.ctime())) f.write(times) print(&quot;猜对了！&quot;) print(times) a1 = &quot;共猜了&apos;&#123;&#125;&apos;次，此次您猜的数字共有&apos;&#123;&#125;\\n&quot;.format(cishu, get_num3) print(a1) f.write(a1) if not_reast == set(): a2 = &quot;没有重复的！\\n&quot; f.write(a2) f.write(&quot;__________________________________________________________________________________\\n\\n\\n&quot;) print(a2) break else: for i in zip(last_dict.items(), last_dict.values()): a3 = &quot; num:&apos;&#123;&#125;&apos;\\t重复&apos;&#123;&#125;&apos;次\\n&quot;.format(i[0][0], i[1]) f.write(a3) print(a3) a4 = &quot;去掉重复的，只算猜了&#123;&#125;次,只输入了&#123;&#125;\\n&quot;.format(len(set(get_num3)), set(get_num3)) f.write(a4) print(a4) f.write(&quot;__________________________________________________________________________________\\n\\n\\n&quot;) break elif new_user &lt; suijishu3: print(&quot;太小了&quot;) cishu += 1# 除了超级管理员(root)以外的管理员def must_root(name): with open(&quot;user_date.txt&quot;,&apos;r&apos;) as f: root_user = json.load(f) with open(&quot;user_mail.txt&quot;,&apos;r&apos;) as m: root_mail = json.load(m) with open(&quot;root.txt&quot;,&apos;r&apos;) as f1: root_user2 = json.load(f1) print(&quot;管理员登录只有一次机会！帐号或密码错误则直接退出&quot;) while True: with open(&quot;user_date.txt&quot;,&apos;r&apos;) as f: root_user = json.load(f) with open(&quot;user_mail.txt&quot;,&apos;r&apos;) as m: root_mail = json.load(m) with open(&quot;root.txt&quot;,&apos;r&apos;) as f1: root_user2 = json.load(f1) print(&quot;亲爱的管理员&apos;&#123;&#125;&apos;,菜单如下:&quot;.format(name)) print(&quot;--------------------&quot;) print(&quot;| 1.删除用户 |&quot;) print(&quot;| 2.查看所有用户名 |&quot;) print(&quot;| 3.暂未开发 |&quot;) print(&quot;| 4.退出登录&quot;) print(&quot;--------------------&quot;) user_selet = input(&quot;&gt;&gt;&gt; &quot;) if user_selet == &quot;1&quot;: print(&quot;请输入需要删除的用户名&quot;) user = input(&quot;&gt;&gt;&gt; &quot;) if user == name: print(&quot;警告! 您无法将自己删除！&quot;) stop() elif user in root_user2: print(&quot;权限不够！您无法删除管理员的&#123;&#125;&quot;.format(user)) time.sleep(0.5) print(&quot;----------------------------&quot;) print(&quot;正在跳转至菜单...&quot;) time.sleep(2) elif user in root_user: try: root_user.pop(user) root_mail.pop(user) except KeyError: pass if os.name == &quot;posix&quot;: # 如果是Linux系统就直接用 &apos;rm&apos; 删除 os.system(&quot;rm game_date/&#123;&#125;&quot;.format(user + &quot;.txt&quot;)) else: # 如果是windows系统就用 &apos;os.remove&apos; 删除 os.remove(&quot;game_date/&#123;&#125;&quot;.format(user + &quot;.txt&quot;)) print(&quot;&apos;&#123;&#125;&apos; 删除成功！&quot;.format(user)) with open(&quot;user_date.txt&quot;, &apos;w&apos;) as f1: json.dump(root_user, f1) with open(&quot;user_mail.txt&quot;, &apos;w&apos;) as f2: json.dump(root_mail, f2) with open(&quot;root_date/&#123;&#125;&quot;.format(name+&quot;.txt&quot;),&apos;a&apos;) as r: r.write(&quot;\\n\\n-------------------------------\\n&quot;) r.write(&quot;于北京时间:&#123;&#125; 删除了用户&apos;&#123;&#125;&apos;&quot;.format(time.ctime(),user)) r.write(&quot;\\n-------------------------------\\n&quot;) stop() else: print(&quot;抱歉，没有找到用户&#123;&#125;&quot;.format(user)) stop() elif user_selet == &quot;2&quot;: for name in root_user: # 全部的用户名都在&quot;user_date.txt&quot;中 if name == &quot;root&quot;: print(&quot;用户名:&#123;&#125;\\t所属权限&apos;&#123;&#125;&apos;&quot;.format(name, &quot;超级管理员&quot;)) elif name in root_user2: # 管理员的用户名在&quot;root.txt&quot;中 print(&quot;用户名:&#123;&#125;\\t所属权限&apos;&#123;&#125;&apos;&quot;.format(name, &quot;管理员&quot;)) else: print(&quot;用户名:&#123;&#125;\\t所属权限&apos;&#123;&#125;&quot;.format(name, &quot;普通玩家&quot;)) stop() elif user_selet == &quot;3&quot;: print(&quot;暂未开发！&quot;) stop() elif user_selet == &quot;4&quot;: print(&quot;管理员&#123;&#125;,已退出!&quot;.format(name)) break else: print(&quot;抱歉，没有&#123;&#125;&quot;.format(user_selet)) stop()def stop(): print(&quot;---------------------------------&quot;) input(&quot;输入任意键继续!&quot;) print(&quot;----------------------------&quot;) print(&quot;正在跳转至菜单...&quot;) time.sleep(2) print(&quot;----------------------------&quot;)# 管理员登录def Root(): print(&quot;----------------&quot;) print(&quot;| ~管理员登录～ |&quot;) print(&quot;----------------&quot;) with open(&quot;user_date.txt&quot;,&apos;r&apos;) as f: root_user = json.load(f) with open(&quot;user_mail.txt&quot;,&apos;r&apos;) as m: root_mail = json.load(m) with open(&quot;root.txt&quot;,&apos;r&apos;) as f1: root_user2 = json.load(f1) with open(&quot;root_mail.txt&quot;,&apos;r&apos;) as m1: root_mail2 = json.load(m1) print(&quot;超级管理员登录只有一次机会！帐号或密码错误则直接退出&quot;) root = input(&quot;帐号: &quot;) password = getpass.getpass(&quot;密码: &quot;) mail = input(&quot;邮箱: &quot;) root_md5 = hasd_md5(root,password) try: if root == &quot;root&quot; and mail == root_mail2[root] and root_md5 == root_user2[root]: print(&quot;登录成功！欢迎您! 超级管理员:&#123;&#125;&quot;.format(root)) while True: with open(&quot;user_date.txt&quot;,&apos;r&apos;) as f: root_user = json.load(f) with open(&quot;user_mail.txt&quot;,&apos;r&apos;) as m: root_mail = json.load(m) with open(&quot;root.txt&quot;,&apos;r&apos;) as f1: root_user2 = json.load(f1) with open(&quot;root_mail.txt&quot;,&apos;r&apos;) as m1: root_mail2 = json.load(m1) print(&quot;亲爱的&#123;&#125;,菜单如下&quot;.format(root)) print(&quot;--------------------&quot;) print(&quot;| 1.删除用户 |&quot;) print(&quot;| 2.创建新的管理员 |&quot;) print(&quot;| 3.查看所有用户 |&quot;) print(&quot;| 4.查看用户注册情况 |&quot;) print(&quot;| 5.退出登录 |&quot;) print(&quot;--------------------&quot;) user_selet = input(&quot;&gt;&gt;&gt; &quot;) if user_selet == &quot;1&quot;: print(&quot;请输入需要删除的用户名&quot;) user = input(&quot;&gt;&gt;&gt; &quot;) if user == &quot;root&quot;: print(&quot;警告！您无法将自己删除！&quot;) stop() elif user in root_user and user not in root_user2: # 删除文本文件中的数据pop() try: root_user.pop(user) root_mail.pop(user) except KeyError: pass # 删除在game_date和root_date中的用户文件 if os.name == &quot;posix&quot;: # 如果是Linux系统就直接用 &apos;rm&apos; 删除 os.system(&quot;rm game_date/&#123;&#125;&quot;.format(user+&quot;.txt&quot;)) else: # 如果是windows系统就用 &apos;os.remove&apos; 删除 os.remove(&quot;game_date/&#123;&#125;&quot;.format(user+&quot;.txt&quot;)) # 把删除掉的数据重新写入 with open(&quot;user_date.txt&quot;,&apos;w&apos;) as f1: json.dump(root_user,f1) with open(&quot;user_mail.txt&quot;,&apos;w&apos;) as f2: json.dump(root_mail,f2) with open(&quot;root_date/root.txt&quot;,&apos;a&apos;) as f3: f3.write(&quot;\\n\\n-------------------------------------------------------------------\\n&quot;) f3.write(&quot;于北京时间:&#123;&#125;，删除了用户&apos;&#123;&#125;&apos;&quot;.format(time.ctime(),user)) f3.write(&quot;\\n-------------------------------------------------------------------\\n&quot;) print(&quot;&apos;&#123;&#125;&apos; 删除成功！&quot;.format(user)) stop() elif user in root_user2: try: root_user.pop(user) root_user2.pop(user) root_mail2.pop(user) except KeyError: pass if os.name == &quot;posix&quot;: os.system(&quot;rm game_date/&#123;&#125;&quot;.format(user+&quot;.txt&quot;)) os.system(&quot;rm root_date/&#123;&#125;&quot;.format(user+&quot;.txt&quot;)) else: os.remove(&quot;game_date/&#123;&#125;&quot;.format(user+&quot;.txt&quot;)) os.remove(&quot;root_date/&#123;&#125;&quot;.format(user+&quot;.txt&quot;)) with open(&quot;user_date.txt&quot;,&apos;w&apos;) as f1: json.dump(root_user,f1) with open(&quot;root.txt&quot;,&apos;w&apos;) as f3: json.dump(root_user2,f3) with open(&quot;root_mail.txt&quot;,&apos;w&apos;) as f4: json.dump(root_mail2,f4) with open(&quot;root_date/&#123;&#125;&quot;.format(root+&quot;.txt&quot;), &apos;a&apos;) as r: r.write(&quot;\\n\\n-------------------------------\\n&quot;) r.write(&quot;于北京时间:&#123;&#125; 删除了用户&apos;&#123;&#125;&apos;&quot;.format(time.ctime(), user)) r.write(&quot;\\n-------------------------------\\n&quot;) print(&quot;&apos;&#123;&#125;&apos; 删除成功！&quot;.format(user)) stop() else: print(&quot;抱歉，没有找到用户&apos;&#123;&#125;&apos;&quot;.format(user)) stop() elif user_selet == &quot;2&quot;: with open(&quot;root.txt&quot;, &apos;r&apos;) as u: # 获取本地文本文件里的用户数据(用户名和密码) root_name = json.load(u) with open(&quot;root_mail.txt&quot;,&apos;r&apos;) as m: # 同上，获取本地用户的用户名和邮箱(两个都是dict) root_main = json.load(m) with open(&quot;user_date.txt&quot;,&apos;r&apos;) as f: user_name = json.load(f) with open(&quot;user_mail.txt&quot;,&apos;r&apos;) as f: user_mail = json.load(f) while True: print(&quot;输入q可退出注册&quot;) get_mail = [i for i in root_main.values()] # 得到邮箱 new_name = input(&quot;root name: &quot;) if new_name == &quot;q&quot; or new_name == &quot;Q&quot;: print(&quot;已取消注册!&quot;) stop() break new_password = getpass.getpass(&quot;root Password: &quot;) again_password = getpass.getpass(&quot;Again Password:&quot;) root_mails = input(&quot;Mail: &quot;) password_chack = [i for i in new_password if i.isalpha()] # 检查密码里面有没有带字母，没有就是[]空list mail_split = root_mails.split(&quot;@&quot;) # 将邮箱拆成两半 mail_re = re.findall(r&apos;[^a-z0-9]+&apos;, mail_split[0]) # 匹配,有数字和字母都ok,其他都不要 if len(new_name.split()) != 1 or (new_name.strip() == new_name) == False: print(&quot;用户名中不能包含空格!&quot;) elif new_password != again_password: # 判断两次的密码是否相同 print(&quot;两次密码不相同,请重新输入!&quot;) continue elif new_name in root_name and new_name in user_name: # 检查 新的用户名有没有在本地数据库中 print(&quot;用户名已经存在！&quot;) continue elif len(new_password) &lt;= 6 or password_chack == []: # 密码长度不能小于6位数，并且至少有一个字母 print(&quot;密码太弱，请输入6位数以上且至少有1一个字母&quot;) elif root_mails in get_mail and root_mail2 in user_mail: # 检查 邮箱有没有被注册 print(&quot;&apos;%s&apos; 邮箱已被注册！&quot; % root_mails) elif mail_re != [] or mail_split[-1] not in [&quot;qq.com&quot;, &quot;gmail.com&quot;,&quot;163.com&quot;]: # 检查 用户输入的邮箱格式 print(&quot;请输入正确的邮箱&quot;) else: get_user_md5 = hasd_md5(new_name, new_password) root_name[new_name] = get_user_md5 root_user[new_name] = get_user_md5 # 数据库里面的都是dict root_main[new_name] = root_mails with open(&quot;root.txt&quot;, &apos;w&apos;) as f: json.dump(root_name, f) # 重新写入本地数据库 os.system(r&quot;echo &gt; root_date/&#123;&#125;.txt&quot;.format(new_name)) # 在注册成功的同时将用户的Game数据创建了～ print(&quot;%s 创建成功！&quot; % new_name) with open(&quot;root_date/&#123;&#125;&quot;.format(root+ &quot;.txt&quot;), &apos;a&apos;) as r: r.write(&quot;\\n\\n-------------------------------\\n&quot;) r.write(&quot;于北京时间:&#123;&#125; 创建了管理员&apos;&#123;&#125;&apos;&quot;.format(time.ctime(), new_name)) r.write(&quot;\\n-------------------------------\\n&quot;) with open(&quot;root_date/&quot; + new_name + &quot;.txt&quot;, &apos;w&apos;) as f: f.write(&quot;----------------------------------------------------------------------------\\n&quot;) f.write(&quot;亲爱的管理员&apos;&#123;&#125;&apos;,欢迎您加入!\\n&quot;.format(new_name)) f.write(&quot;创建时间: &quot;) f.write(time.ctime()) f.write(&quot;\\n---------------------------------------------------------------------------\\n\\n\\n&quot;) with open(&quot;root_mail.txt&quot;, &apos;w&apos;) as s: json.dump(root_main, s) with open(&quot;user_date.txt&quot;,&apos;w&apos;) as f: json.dump(root_user,f) with open(&quot;game_date/&quot; + new_name + &quot;.txt&quot;, &apos;w&apos;) as f: f.write(&quot;----------------------------------------------------------------------------\\n&quot;) f.write(&quot;亲爱的&apos;&#123;&#125;&apos;,欢迎您加入!\\n&quot;.format(new_name)) f.write(&quot;创建时间: &quot;) f.write(time.ctime()) f.write(&quot;\\n您拥有管理员权限&quot;) f.write(&quot;\\n---------------------------------------------------------------------------\\n\\n\\n&quot;) break elif user_selet == &quot;3&quot;: with open(&quot;user_mail.txt&quot;, &apos;r&apos;) as m: mails = json.load(m) with open(&quot;root.txt&quot;, &apos;r&apos;) as r: spuer = json.load(r) with open(&quot;root_mail.txt&quot;, &apos;r&apos;) as rm: spuer_mail = json.load(rm) with open(&quot;user_date.txt&quot;,&apos;r&apos;) as user_date: user_dates = json.load(user_date) print(&quot;-----------------------&quot;) print(&quot;| 1.查看用户名 |&quot;) print(&quot;| 2.查看用户名和邮箱 |&quot;) print(&quot;-----------------------&quot;) user = input(&quot;&gt;&gt;&gt; &quot;) if user == &quot;1&quot;: for name in user_dates: if name == &quot;root&quot;: print(&quot;用户名:&#123;&#125;\\t所属权限&apos;&#123;&#125;&apos;&quot;.format(name,&quot;超级管理员&quot;)) elif name in spuer: print(&quot;用户名:&#123;&#125;\\t所属权限&apos;&#123;&#125;&apos;&quot;.format(name, &quot;管理员&quot;)) else: print(&quot;用户名:&#123;&#125;\\t所属权限&apos;&#123;&#125;&apos;&quot;.format(name, &quot;普通玩家&quot;)) stop() elif user == &quot;2&quot;: a = [i for i in spuer.keys()] # 因为root.txt文件里没有管理员的邮箱，所以要吧root_mail.txt里面的邮箱添加到root.txt中(mails) for i in zip(spuer_mail.keys(), spuer_mail.values()): mails[i[0]] = i[1] for mail in zip(mails.keys(), mails.values()): if mail[0] == &quot;root&quot;: print(&quot;用户名:&#123;&#125;\\t邮箱:&#123;&#125;\\t所属权限&apos;&#123;&#125;&apos;&quot;.format(mail[0], mail[1], &quot;超级管理员&quot;)) elif mail[0] in a: print(&quot;用户名:&#123;&#125;\\t邮箱:&#123;&#125;\\t所属权限&apos;&#123;&#125;&apos;&quot;.format(mail[0], mail[1], &quot;管理员&quot;)) else: print(&quot;用户名:&#123;&#125;\\t邮箱:&#123;&#125;\\t所属权限&apos;&#123;&#125;&apos;&quot;.format(mail[0], mail[1], &quot;普通玩家&quot;)) stop() else: print(&quot;抱歉，没有&#123;&#125;&quot;.format(user)) stop() elif user_selet == &quot;4&quot;: with open(&quot;date.txt&quot;,&apos;r&apos;) as date: if os.name == &quot;posix&quot;: os.system(&quot;gedit date.txt&quot;) else: os.system(&quot;date.txt&quot;) stop() elif user_selet == &quot;5&quot;: print(&quot;&#123;&#125; 已退出！&quot;.format(root)) break else: print(&quot;抱歉，没有选项&#123;&#125;&quot;.format(user_selet)) stop() elif mail != root_mail2[root]: print(&quot;邮箱错误！&quot;) elif root in root_user2 and mail == root_mail2[root] and root_md5 == root_user2[root]: print(&quot;管理员&apos;&#123;&#125;&apos;,欢迎您！&quot;.format(root)) must_root(root) else: print(&quot;管理员帐号或密码错误&quot;) except KeyError: print(&quot;&#123;&#125;，您不是管理员！&quot;.format(root))if __name__ == &quot;__main__&quot;: print(&quot;Welcome to Guess number Game2.0&quot;) print(&quot;----------------&quot;) print(&quot;| 1.login |&quot;) print(&quot;| 2.registere |&quot;) print(&quot;| 3.Root login |&quot;) print(&quot;----------------&quot;) print(&quot;游戏开始前请登录或者注册！&quot;) try: os.mkdir(&quot;game_date&quot;) open(&quot;game_date/root.txt&quot;,&apos;w&apos;) os.mkdir(&quot;root_date&quot;) open(&quot;root_date/root.txt&quot;,&apos;w&apos;) except FileExistsError: pass start_Game = input(&quot;1~2~3 &quot;) if start_Game == &quot;1&quot;: ReL = Register() ReL.Login() elif start_Game == &quot;2&quot;: print(&quot;REGISTERED!&quot;) Re = Register() if Re.register() == &quot;A&quot;: # R = Register() Re.Login() elif start_Game == &quot;3&quot;: print(&quot;管理员登录&quot;) Root() else: print(&quot;抱歉，选项中没有 &apos;%s&apos;&quot; % start_Game) 运行效果: 这是源代码以后可能还会增加其他东西,比如签到啊，排行榜啊这些的，而且，命令行模式玩起来一点也不舒服，对吧？有更新我会在这篇文章末尾添加更新说明,期待一下吧～～我感觉我算是全国首个喜欢猜数字小游戏的人，猜个数字都那么麻烦…. 2017年4月4日00:24更新: 无需手动创建文件，运行.py程序自动创建 增加首次运行可自定义root帐号和root密码用户id未完善，图形界面正在开发中……(有数据库id不搞了) 2017年5月22日15:24更新: 丢弃txt文本,用数据库存储 增加两个小功能～新版本请前往这里下载","path":"2017/03/04/Guess-number2-0/","date":"03-04","excerpt":"猫是可爱的，狼是很帅的。就是说，孤独又可爱又帅。 ————大老师引用了大老师的话，嘿嘿～我最喜爱的动漫角色就是”大老师”，我也是动漫迷嘛～小萝莉太棒了！——咳咳～这篇本来打算过年的时候就发的(没网)，加上这几天没时间，所以给忘了，这个程序是我在过年的时候无聊写的，因为实在是闲得扣脚…除了吃就是睡，主要还没网(农村嘛～)，补上补上～～～","tags":[{"name":"Python","slug":"Python","permalink":"https://liuyangxiong.cn/tags/Python/"}]},{"title":"python3 爬取 ”百思不得姐“ 所有视频和图片","text":"这个算是我的第一次爬虫经验，虽然很容易就实现了，代码量相当的少，也挺满足了，自己也是从菜鸟慢慢的爬起来的,虽然现在也挺菜的…. 爬取的目标是：http://www.budejie.com/工具： Linuxpython 3Sublime Text 3终端 需要用到的模块： urllibBeautifulSouplxml urllibpython3里面已经自带了,所以需要下载的只有BeautifulSoup和lxml安装方法： pip3 bs4pip3 lxml 注：BeautifulSoup在bs4下面,所以直接安装bs4再注：lxml模块在windows下安装是会报错的,Google一下解决方法吧好了，把东西都全部齐全之后，开始吧！下面是爬视频的代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding: utf-8 -*-# 引入模块import urllib.requestfrom bs4 import BeautifulSoupimport osimport urllib.errordef Replace(url): url = url.replace(&quot;mvideo&quot;,&quot;svideo&quot;) url = url.replace(&quot;cn&quot;,&quot;com&quot;) url = url.replace(&quot;wpcco&quot;,&quot;wpd&quot;) return urltime = 1while True: url = &quot;http://www.budejie.com/video/&quot;+str(time) headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36&quot;&#125; url_Request = urllib.request.Request(url,headers=headers) try: url_open = urllib.request.urlopen(url_Request) except urllib.error.HTTPError as e: print(&quot;页面没有找到&quot;,e.code) url_soup = BeautifulSoup(url_open.read().decode(&quot;utf-8&quot;),&apos;lxml&apos;) try: url_div = url_soup.find(&quot;div&quot;,class_=&quot;j-r-c&quot;).find_all(&quot;div&quot;,class_=&quot; j-video&quot;) url_name = url_soup.find_all(&quot;li&quot;,class_=&quot;j-r-list-tool-l-down f-tar j-down-video j-down-hide ipad-hide&quot;) except AttributeError as f: print(&quot;已经爬完了...这个网站页面不多~不信自己翻一翻&quot;) break name = [] #用来储存视频的名字 div = [] # 用来储存视频的地址 replace_name = [] # 将视频名字中的一些特殊字符换掉 for i in url_name: name.append(i[&quot;data-text&quot;]) for z in name: z = z.replace(&quot;\\&quot;&quot;,&quot;&apos;&quot;) replace_name.append(z) for x in url_div: video_url = Replace(x[&quot;data-mp4&quot;]) div.append(video_url) print(&quot;------------------------------------&quot;) print(&quot;正在下载第 %s 页&quot; % time) for z in zip(replace_name,div): try: print(&quot;Downloading... %s&quot; % z[0]) try: urllib.request.urlretrieve(z[1],&quot;baisibudeqijie_video//%s.mp4&quot; % z[0]) print(&quot;%s Download complite!&quot; % z[0]) except OSError as o: print(&quot;文件出错啦~可能是有特殊符号~也有可能是链接消失啦~这张就下载不了啦~&quot;,o) except UnicodeEncodeError as u: print(&quot;你用的可能是windows系统吧~这里报错“GBK”了~用Linux系统吧~&quot;) print(&quot;或者在cmd窗口下输入: chcp 65001 就可以改成&apos;utf-8&apos;了&quot;) except urllib.error.HTTPError as f: print(&quot;图片链接没有找到,可能是被删除了吧～&quot;,f.code) except FileNotFoundError as e: print(&quot;视频链接没有找到,可能被删除了吧～&quot;,e) pass print(&quot;第 %s 页已下载完成&quot; % time) print(&quot;------------------------------------&quot;) time+=1 下面是爬取图片的，其实和视频差不多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: utf-8 -*- import urllib.requestfrom bs4 import BeautifulSoupimport osimport urllib.errortime = 1while True: url = &quot;http://www.budejie.com/pic/&quot;+str(time) headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36&quot;&#125; url_Request = urllib.request.Request(url,headers=headers) try: url_open = urllib.request.urlopen(url_Request) except urllib.error.HTTPError as f: print(&quot;页面没有找到&quot;,f.code) url_soup = BeautifulSoup(url_open.read().decode(&quot;utf-8&quot;),&apos;lxml&apos;) try: url_div = url_soup.find(&quot;div&quot;,class_=&quot;j-r-list&quot;).find_all(&quot;img&quot;) except AttributeError as e: print(&quot;已经爬完了，这个网页的页面不多～不信自己翻一翻&quot;) break url_img = [] # 图片的地址 url_name = [] # 图片的名字 for i in url_div: url_img.append(i[&quot;data-original&quot;]) url_name.append(i[&quot;alt&quot;]) url_reght = [] # 这个网站的图片会有一些不是图片的链接出现，没有后缀的~下载下来也没用，把它去掉 a = [&quot;.gif&quot;,&quot;.png&quot;,&quot;.jpg&quot;] for i in url_img: if i[-4:] in a: url_reght.append(i) url_name_split = [] # 因为字符串太长，储存的时候会报错，就截取&apos;，&apos;前面第一个 for name_split in url_name: url_name_split.append(name_split.split(&quot;，&quot;)) print(&quot;--------------------------------&quot;) print(&quot;正在下载第 %s 页&quot; % time) for download in zip(url_name_split,url_reght): try: print(&quot;Download... %s&quot; % download[0][0]) try: urllib.request.urlretrieve(download[1],&quot;baisibudeqijie_img//%s&quot; % (download[0][0]+download[1][-5:])) except OSError as o: print(&quot;文件出错啦~可能是有特殊符号~也有可能是链接消失啦~这张就下载不了啦~&quot;,o) print(&quot;%s download complite!&quot; % download[0][0]) except UnicodeEncodeError as u: print(&quot;你用的可能是windows系统吧~这里报错“GBK”了~用Linux系统吧~&quot;) print(&quot;或者在cmd窗口下输入: chcp 65001 就可以改成&apos;utf-8&apos;了&quot;) except urllib.error.HTTPError as f: print(&quot;图片链接没有找到,可能是被删除了吧～&quot;,f.code) except FileNotFoundError as e: print(&quot;图片链接没有找到,可能是被删除了吧～&quot;,e) pass print(&quot;第 %s 页已经下载完成&quot; % time) print(&quot;--------------------------------&quot;) time+=1 好了,爬取 ”百思不得姐“ 的视频和图片就这么多代码，是不是相当简单，如果用requests就更简单了我们把这两个合起来: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# -*- condig: utf-8 -*-import urllib.requestfrom bs4 import BeautifulSoupimport osimport urllib.errordef Replace(url): url = url.replace(&quot;mvideo&quot;,&quot;svideo&quot;) url = url.replace(&quot;cn&quot;,&quot;com&quot;) url = url.replace(&quot;wpcco&quot;,&quot;wpd&quot;) return urldef video(): time = 1 while True: url = &quot;http://www.budejie.com/video/&quot;+str(time) headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36&quot;&#125; url_Request = urllib.request.Request(url,headers=headers) try: url_open = urllib.request.urlopen(url_Request) except urllib.error.HTTPError as e: print(&quot;页面没有找到&quot;,e.code) url_soup = BeautifulSoup(url_open.read().decode(&quot;utf-8&quot;),&apos;lxml&apos;) try: url_div = url_soup.find(&quot;div&quot;,class_=&quot;j-r-c&quot;).find_all(&quot;div&quot;,class_=&quot; j-video&quot;) url_name = url_soup.find_all(&quot;li&quot;,class_=&quot;j-r-list-tool-l-down f-tar j-down-video j-down-hide ipad-hide&quot;) except AttributeError as f: print(&quot;已经爬完了...这个网站页面不多~不信自己翻一翻&quot;) break name = [] #用来储存视频的名字 div = [] # 用来储存视频的地址 replace_name = [] # 将视频名字中的一些特殊字符换掉 for i in url_name: name.append(i[&quot;data-text&quot;]) for z in name: z = z.replace(&quot;\\&quot;&quot;,&quot;&apos;&quot;) replace_name.append(z) for x in url_div: video_url = Replace(x[&quot;data-mp4&quot;]) div.append(video_url) print(&quot;------------------------------------&quot;) print(&quot;正在下载第 %s 页&quot; % time) for z in zip(replace_name,div): try: print(&quot;Downloading... %s&quot; % z[0]) try: urllib.request.urlretrieve(z[1],&quot;baisibudeqijie_video//%s.mp4&quot; % z[0]) print(&quot;%s Download complite!&quot; % z[0]) except OSError as o: print(&quot;文件出错啦~可能是有特殊符号~也有可能是链接消失啦~这张就下载不了啦~&quot;,o) except UnicodeEncodeError as u: print(&quot;你用的可能是windows系统吧~这里报错“GBK”了~用Linux系统吧~&quot;) print(&quot;或者在cmd窗口下输入: chcp 65001 就可以改成&apos;utf-8&apos;了&quot;) except urllib.error.HTTPError as f: print(&quot;图片链接没有找到,可能是被删除了吧～&quot;,f.code) except FileNotFoundError as e: print(&quot;视频链接没有找到,可能被删除了吧～&quot;,e) pass print(&quot;第 %s 页已下载完成&quot; % time) print(&quot;------------------------------------&quot;) time+=1def img(): time = 1 while True: url = &quot;http://www.budejie.com/pic/&quot;+str(time) headers = &#123;&quot;User-Agent&quot;:&quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36&quot;&#125; url_Request = urllib.request.Request(url,headers=headers) try: url_open = urllib.request.urlopen(url_Request) except urllib.error.HTTPError as f: print(&quot;页面没有找到&quot;,f.code) url_soup = BeautifulSoup(url_open.read().decode(&quot;utf-8&quot;),&apos;lxml&apos;) try: url_div = url_soup.find(&quot;div&quot;,class_=&quot;j-r-list&quot;).find_all(&quot;img&quot;) except AttributeError as e: print(&quot;已经爬完了，这个网页的页面不多～不信自己翻一翻&quot;) break url_img = [] # 图片的地址 url_name = [] # 图片的名字 for i in url_div: url_img.append(i[&quot;data-original&quot;]) url_name.append(i[&quot;alt&quot;]) url_reght = [] # 这个网站的图片会有一些不是图片的链接出现，没有后缀的~下载下来也没用，把它去掉 a = [&quot;.gif&quot;,&quot;.png&quot;,&quot;.jpg&quot;] for i in url_img: if i[-4:] in a: url_reght.append(i) url_name_split = [] # 因为字符串太长，储存的时候会报错，就截取&apos;，&apos;前面第一个 for name_split in url_name: url_name_split.append(name_split.split(&quot;，&quot;)) print(&quot;--------------------------------&quot;) print(&quot;正在下载第 %s 页&quot; % time) for download in zip(url_name_split,url_reght): try: print(&quot;Download... %s&quot; % download[0][0]) try: urllib.request.urlretrieve(download[1],&quot;baisibudeqijie_img//%s&quot; % (download[0][0]+download[1][-5:])) except OSError as o: print(&quot;文件出错啦~可能是有特殊符号~也有可能是链接消失啦~这张就下载不了啦~&quot;,o) print(&quot;%s download complite!&quot; % download[0][0]) except UnicodeEncodeError as u: print(&quot;你用的可能是windows系统吧~这里报错“GBK”了~用Linux系统吧~&quot;) print(&quot;或者在cmd窗口下输入: chcp 65001 就可以改成&apos;utf-8&apos;了&quot;) except urllib.error.HTTPError as f: print(&quot;图片链接没有找到,可能是被删除了吧～&quot;,f.code) except FileNotFoundError as e: print(&quot;图片链接没有找到,可能是被删除了吧～&quot;,e) pass print(&quot;第 %s 页已经下载完成&quot; % time) print(&quot;--------------------------------&quot;) time+=1print(&quot;--------------------------------&quot;)print(&quot;| 1.video |&quot;)print(&quot;| 2.img |&quot;)print(&quot;--------------------------------&quot;)user = input(&quot;请选择1 or 2: &quot;)if user == &quot;1&quot;: print(&quot;正在获取页面...&quot;) try: os.mkdir(&quot;baisibudeqijie_video&quot;) if os.path.exists(&quot;baisibudeqijie_video&quot;): os.rmdir(&quot;baisibudeqijie_video&quot;) os.mkdir(&quot;baisibudeqijie_video&quot;) except FileExistsError: pass video()elif user == &quot;2&quot;: print(&quot;正在获取页面...&quot;) try: os.mkdir(&quot;baisibudeqijie_img&quot;) if os.path.exists(&quot;baisibudeqijie_img&quot;): os.rmdir(&quot;baisibudeqijie_img&quot;) os.mkdir(&quot;baisibudeqijie_img&quot;) except FileExistsError: pass img()else: print(&quot;抱歉,选项里没有 &apos;%s&apos;&quot; % user) 运行结果: 视频的运行结果是一样的～后来我索性把这个网站的所以东西都爬了～包括音乐～段子～美女，这个是 源代码，参考参考吧～","path":"2016/12/21/baisibudejie/","date":"12-21","excerpt":"这个算是我的第一次爬虫经验，虽然很容易就实现了，代码量相当的少，也挺满足了，自己也是从菜鸟慢慢的爬起来的,虽然现在也挺菜的….","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"https://liuyangxiong.cn/tags/Python爬虫/"}]},{"title":"Python3 猜数字游戏","text":"猜数字游戏，题目要求是：随机生成一个数字，用户输入一个数字，判断用户猜对了没有，没有就继续猜，直到猜对为止，并且把用户所猜的所有的数字打印出来，有重复的便丢去。 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041from random import randintgenerate_list = [] # 用来放用户所输入的所有数reset_repeat = &#123;&#125; # 用来放删除的重复的数compute_total = &#123;&#125; # 用来放重复的数get_list = [] # 获取所有重复的数的个数cishu = 0one_num = randint(1,20) # 生产随机数字print(&quot;请输入不大于20,不小于0的整数&quot;)while True: cishu+=1 user_input = input(&quot;&gt;&gt;&gt;&quot;) # 用户输入 reset_repeat[user_input]=1 generate_list.append(user_input) # 将用户所输入的数字放在 `generate_list` 中 s = generate_list.count(user_input) # 获得重复数字的个数 compute_total[user_input]=s # 获得重复数字的次数放入 `compute_toatl` reset_list = [i for i in generate_list if generate_list.count(i) &gt; 1] # 去掉重复一次以下的 get_num = set(reset_list) # 利用set去掉重复的数字 reset_list_2 = [i for i in generate_list if generate_list.count(i)] L = &#123;&#125; len_size = len(set(reset_list_2)) for i in get_num: # 遍历get_num,将里面的数添加到 `get_list` f = compute_total.get(i) get_list.append(f) L[i]=get_list[-1] # 得到所有数的一次 if user_input.isnumeric(): user_input = int(user_input) if user_input &gt; 20 or user_input &lt; 0: raise &quot;must 0`20!&quot; if user_input &gt; one_num: if isinstance(user_input,int): print(&quot;您猜的是 &apos;%s&apos; 太大了！&quot; % (user_input)) elif user_input == one_num: if isinstance(user_input,int): print(&quot;恭喜您！猜对了！&quot;) print(&quot;共猜测了&apos;%s&apos;次，此次您输入的数字都有：%s,重复的有: %s,全部重复的只能算一次,所以最后只输入了： %s 所以您只猜了%s次&quot; % (cishu,generate_list,L,sorted(set(reset_list_2)),len_size)) break elif user_input &lt; one_num: if isinstance(user_input,int): print(&quot;您猜的是 &apos;%s&apos; 太小啦！&quot; % (user_input)) else: raise &quot;must be a intget!&quot; 运行结果：","path":"2016/12/15/Guess-number/","date":"12-15","excerpt":"猜数字游戏，题目要求是：随机生成一个数字，用户输入一个数字，判断用户猜对了没有，没有就继续猜，直到猜对为止，并且把用户所猜的所有的数字打印出来，有重复的便丢去。","tags":[{"name":"Python","slug":"Python","permalink":"https://liuyangxiong.cn/tags/Python/"}]},{"title":"Python3 实现196问题","text":"196问题其实就是得到一个数的回数，和6174问题差不多，只是算法不一样，6174是排序最大减去最小的，而196是把数倒过来加，比如：数字67,就是67+76=143，143+341=484 这个484就是67的回数 代码如下： 123456789a = input(&quot;请输入两位数以上的整数： &quot;)s = awhile True: f = a if a == a[::-1]: break a = str(int(a)+int(a[::-1])) print(&quot;%s + %s = %s&quot; % (f,f[::-1],a))print(&quot;%s 最后的回数是： %s&quot; % (s,a)) 运行结果：","path":"2016/12/14/196-priblem/","date":"12-14","excerpt":"196问题其实就是得到一个数的回数，和6174问题差不多，只是算法不一样，6174是排序最大减去最小的，而196是把数倒过来加，比如：数字67,就是67+76=143，143+341=484 这个484就是67的回数","tags":[{"name":"Python","slug":"Python","permalink":"https://liuyangxiong.cn/tags/Python/"}]},{"title":"模拟注册-登录-找回密码,把用户的数据放到本地文件","text":"题目原先是来自廖雪峰的,在hashlib的那个章节，作业就是模拟注册登录,我改了改，然后增加了一个可以找回密码 首先，我们创建五个文本文件：login.py，registered.py,Find_password.py,date.txt,find_password_date.txt（在同一个目录下）login.py主要的，用来执行registered.py 注册用Find_password.py 找回密码date.txt用来存储用户的帐号和密码find_password_date.txt用来存储用户输入的帐号和邮箱，我们先写用户注册用的，打开registered.py内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243#! /uer/bin/python3.5# -*- coding: utf-8 -*-import hashlib,json,re,getpassdef get_md5(user,password): md5 = hashlib.md5() md5.update((user+password+&quot;The*Sale&quot;).encode(&apos;utf-8&apos;)) return md5.hexdigest()mail_gesi = [&quot;qq.com&quot;,&quot;gmail.com&quot;,&quot;163.com&quot;]def register(): with open(&quot;date.txt&quot;,&apos;r&apos;) as f: user_date = json.load(f) with open(&quot;find_password_date.txt&quot;,&apos;r&apos;) as a: find_password = json.load(a) while True: mail_list = [x for x in find_password.values()] # 获取之前用户输入过的所有邮箱 user = str(input(&quot;New User: &quot;)) if user == &apos;q&apos;: break password = getpass.getpass(&quot;Password: &quot;) password_chack = [i for i in password if i.isalpha()] # 判断 password 中是否有英文字母 mail = str(input(&quot;Mail: &quot;)) save_md5 = get_md5(user,password) # 将用户输入的密码加密 mail_split = mail.split(&quot;@&quot;) mail_re = re.findall(r&quot;[^a-z0-9]+&quot;,mail_split[0]) if user in user_date: print(&quot;&apos;%s&apos; 已存在，请重新输入！&quot; % user) continue elif len(password) &lt; 6 or password_chack == []: # 判断密码是否大于6个和是否带有英文字母 print(&quot;密码太弱，请输入6位以上的并且至少有一个英文字母&quot;) elif mail in mail_list: # 判断有没有被其他用户输入过 print(&quot;此邮箱已注册！&quot;) elif mail_re != [] or mail_split[-1] not in mail_gesi: # 判断邮箱格式 print(&quot;请输入正确的邮箱&quot;) print(&quot;输入&apos;q&apos;可退出注册&quot;) else: user_date[user]=save_md5 find_password[user]=mail print(&quot;&apos;%s&apos; 创建成功！&quot; % user) with open(&quot;date.txt&quot;,&apos;w&apos;) as s: json.dump(user_date,s) with open(&quot;find_password_date.txt&quot;,&apos;w&apos;) as x: json.dump(find_password,x) break Find_password.py的内容是： 123456789101112131415161718192021222324252627# -*- coding: utf-8 -*-import json,getpassfrom registered import *def Find_password(): with open(&quot;find_password_date.txt&quot;,&apos;r&apos;) as f: mail_date = json.load(f) with open(&quot;date.txt&quot;,&apos;r&apos;) as d: user_date = json.load(d) while True: user = str(input(&quot;User: &quot;)) mail = str(input(&quot;Mail: &quot;)) if user in mail_date and mail == mail_date[user]: while True: new_password = getpass.getpass(&quot;New Password&quot;) enter_password = getpass.getpass(&quot;Enter Password: &quot;) if new_password == enter_password: get_new_md5 = get_md5(user,new_password) user_date[user]=get_new_md5 print(&quot;密码修改成功！&quot;) with open(&quot;date.txt&quot;,&apos;w&apos;) as x: json.dump(user_date,x) break else: print(&quot;两次输入的密码不相同，请重新输入！&quot;) break else: print(&quot;用户名或错误!&quot;) 最后是登录用的login.py: 123456789101112131415161718192021222324252627282930313233# -*- codint: utf-8 -*-import json,getpassfrom registered import *from Find_password import * while True: print(&quot;User Login!&quot;) with open(&quot;date.txt&quot;,&quot;r&quot;) as f: user_date = json.load(f) user = str(input(&quot;User Name: &quot;)) password = getpass.getpass(&quot;Password: &quot;) save_md5 = get_md5(user,password) if user not in user_date: print(&quot;用户名: &apos;%s&apos; 不存在，请注册！&quot; % user) print(&quot;输入&apos;q&apos;退出,输入&apos;a&apos;继续注册&quot;) sele = str(input(&quot;q or a: &quot;)) if sele == &quot;q&quot;: print(&quot;已退出！&quot;) break print(&quot;REGISTERED!&quot;) register() else: if user in user_date and user_date[user]==save_md5: print(&quot;Login success!&quot;) print(&quot;Welcome %s&quot; % user) break else: print(&quot;密码或帐号错误，是否需要找回密码？(y/n)&quot;) enter = str(input(&quot;&gt;&gt;&gt; &quot;)) if enter == &quot;Y&quot; or enter == &quot;y&quot;: Find_password() else: continue 现在就直接运行login.py，是会报错的，因为我们在注册的时候，json会去读取本地文件data.txt和find_password_data.txt,因为刚开始这两个文件里面是还没有内容的，你得先存入一个数据才行，否则会报错！所以，我们先在data.txt里面写入： {“root”: “63a9f0ea7bb98050796b649e85481845”} 同样的，在find_password_data.txt写入: “root”: “123456789@gmail.com“} 下面是运行结果： 不想把他分成三个文件的话，就全部放在一个.py吧，我把他分开储存是因为，要更改或添加的时候方便～下面是三个.py文件的总和： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#! /uer/bin/python3.5# -*- coding: utf-8 -*-import hashlib,json,re,getpassdef get_md5(user,password): md5 = hashlib.md5() md5.update((user+password+&quot;The*Sale&quot;).encode(&apos;utf-8&apos;)) return md5.hexdigest()mail_gesi = [&quot;qq.com&quot;,&quot;gmail.com&quot;,&quot;163.com&quot;]def register(): with open(&quot;date.txt&quot;,&apos;r&apos;) as f: user_date = json.load(f) with open(&quot;find_password_date.txt&quot;,&apos;r&apos;) as a: find_password = json.load(a) while True: mail_list = [x for x in find_password.values()] # 获取之前用户输入过的所有邮箱 user = str(input(&quot;New User: &quot;)) if user == &apos;q&apos;: break password = getpass.getpass(&quot;Password: &quot;) password_chack = [i for i in password if i.isalpha()] # 判断 password 中是否有英文字母 mail = str(input(&quot;Mail: &quot;)) save_md5 = get_md5(user,password) # 将用户输入的密码加密 mail_split = mail.split(&quot;@&quot;) mail_re = re.findall(r&quot;[^a-z0-9]+&quot;,mail_split[0]) if user in user_date: print(&quot;&apos;%s&apos; 已存在，请重新输入！&quot; % user) continue elif len(password) &lt; 6 or password_chack == []: # 判断密码是否大于6个和是否带有英文字母 print(&quot;密码太弱，请输入6位以上的并且至少有一个英文字母&quot;) elif mail in mail_list: # 判断有没有被其他用户输入过 print(&quot;此邮箱已注册！&quot;) elif mail_re != [] or mail_split[-1] not in mail_gesi: # 判断邮箱格式 print(&quot;请输入正确的邮箱&quot;) print(&quot;输入&apos;q&apos;可退出注册&quot;) else: user_date[user]=save_md5 find_password[user]=mail print(&quot;&apos;%s&apos; 创建成功！&quot; % user) with open(&quot;date.txt&quot;,&apos;w&apos;) as s: json.dump(user_date,s) with open(&quot;find_password_date.txt&quot;,&apos;w&apos;) as x: json.dump(find_password,x) breakdef Find_password(): with open(&quot;find_password_date.txt&quot;,&apos;r&apos;) as f: mail_date = json.load(f) with open(&quot;date.txt&quot;,&apos;r&apos;) as d: user_date = json.load(d) while True: user = str(input(&quot;User: &quot;)) mail = str(input(&quot;Mail: &quot;)) if user in mail_date and mail == mail_date[user]: while True: new_password = getpass.getpass(&quot;New Password&quot;) enter_password = getpass.getpass(&quot;Enter Password: &quot;) if new_password == enter_password: get_new_md5 = get_md5(user,new_password) user_date[user]=get_new_md5 print(&quot;密码修改成功！&quot;) with open(&quot;date.txt&quot;,&apos;w&apos;) as x: json.dump(user_date,x) break else: print(&quot;两次输入的密码不相同，请重新输入！&quot;) break else: print(&quot;用户名或错误!&quot;)while True: print(&quot;User Login!&quot;) with open(&quot;date.txt&quot;,&quot;r&quot;) as f: user_date = json.load(f) user = str(input(&quot;User Name: &quot;)) password = getpass.getpass(&quot;Password: &quot;) save_md5 = get_md5(user,password) if user not in user_date: print(&quot;用户名: &apos;%s&apos; 不存在，请注册！&quot; % user) print(&quot;输入&apos;q&apos;退出,输入&apos;a&apos;继续注册&quot;) sele = str(input(&quot;q or a: &quot;)) if sele == &quot;q&quot;: print(&quot;已退出！&quot;) break print(&quot;REGISTERED!&quot;) register() else: if user in user_date and user_date[user]==save_md5: print(&quot;Login success!&quot;) print(&quot;Welcome %s&quot; % user) break else: print(&quot;密码或帐号错误，是否需要找回密码？(y/n)&quot;) enter = str(input(&quot;&gt;&gt;&gt; &quot;)) if enter == &quot;Y&quot; or enter == &quot;y&quot;: Find_password() else: continue 结果是一样的","path":"2016/12/14/Login/","date":"12-14","excerpt":"题目原先是来自廖雪峰的,在hashlib的那个章节，作业就是模拟注册登录,我改了改，然后增加了一个可以找回密码","tags":[{"name":"Python","slug":"Python","permalink":"https://liuyangxiong.cn/tags/Python/"}]},{"title":"Python3 实现数学黑洞6174","text":"6174猜想：一个任意的四位正整数（全相同的除外，如1111）。将数字重新组合成一个最大的数和最小的数相减，重复这个过程，最多七步，必得6174。 6174百度百科 还有一个数是495,和6174一个道理，一个任意的三位正整数，然后排列最大减去最小，重复下去一直到495用python3实现： 1234567891011121314151617181920# -*- coding: utf-8 -*-from functools import reducex = str(input(&quot;请输入四位数或者三位数的数字： &quot;))times = 1while True: if len(x) &gt; 4: print(&quot;不能超过4位数&quot;) break max_math = sorted(x,reverse=True) min_math = sorted(x) max_math_switch_str = int(reduce(lambda x,y:x+y,max_math)) min_math_switch_str = int(reduce(lambda x,y:x+y,min_math)) s = max_math_switch_str-min_math_switch_str print(&quot;now&quot;,times,max_math_switch_str,&quot;-&quot;,min_math_switch_str,&quot;=&quot;,s) if s == 6174: break if s == 495: break x = str(s) times += 1 下面是运行结果：","path":"2016/12/13/6174-priblem/","date":"12-13","excerpt":"6174猜想：一个任意的四位正整数（全相同的除外，如1111）。将数字重新组合成一个最大的数和最小的数相减，重复这个过程，最多七步，必得6174。","tags":[{"name":"Python","slug":"Python","permalink":"https://liuyangxiong.cn/tags/Python/"}]},{"title":"Python3 查看英文文章单词出现的次数","text":"查看英文文章里面的单词出现的次数，暂时还没有发现问题 12345678910111213141516171819202122232425262728293031323334# -*- coding: utf-8 -*-&quot;&quot;&quot;统计英文单词出现的个数&quot;&quot;&quot;import reclass FindWord: def __init__(self,path=&quot;English.txt&quot;,word_dict=&#123;&#125;): self.path = path self.word_dict = word_dict def find(self): print(&quot;View all or one(total\\one)&quot;) poi = input(&quot;View: &quot;) time = 1 with open(self.path,&apos;r&apos;) as f: read_word = f.read() match = re.findall(r&quot;[^a-zA-Z0-9&apos;]+&quot;,read_word) for i in match: read_word = read_word.replace(i,&quot; &quot;) lines = read_word.split() for x in lines: if x in self.word_dict: self.word_dict[x]+=1 else: self.word_dict[x]=1 if poi == &quot;total&quot;: for keys,values in sorted(self.word_dict.items()): time+=1 print(&quot;%3d %-20s 出现了‘%s&apos;次&quot; % (time,keys,values)) elif poi == &quot;one&quot;: user_input = input(&quot;Word: &quot;) get_word = self.word_dict.get(user_input,&quot;No Found.&quot;) print(&quot;&apos;%s&apos; 出现了&apos;%s&apos;次&quot; % (user_input,get_word)) else: print(&quot;No &apos;%s&apos; parameter&quot; % poi) 文章的内容是： However mean your life is,meet it and live it ;do not shun it and call it hard names.It &gt; is not so bad as you are.It looks poorest when you are richest.The fault-finder willfind faults in paradise.Love your life,poor as it is.You may perhaps have some pleasant,thrilling,glorious hourss,even in a poor-house.The setting sun is reflected from the windows of the alms-house as brightly as from the rich man’s abode;the snow melts before its door as early in the spring.I do not see but a quiet mind may live as contentedly there,and have as cheering thoughts,as in a palace.The town’s poor seem to me often to live the most independent lives of any.May be they are simply great enough to receive without misgiving.Most think that they are above being supported by the town;but it often happens that they are not above supporting themselves by dishonest means.which should be more disreputable.Cultivate poverty like a garden herb,like sage.Do not trouble yourself much to get new things,whether clothes or friends,Turn the old,return to them.Things do not change;we change.Sell your clothes and keep your thoughts. 下面是运行的结果：","path":"2016/12/13/Find-words/","date":"12-13","excerpt":"查看英文文章里面的单词出现的次数，暂时还没有发现问题","tags":[{"name":"Python","slug":"Python","permalink":"https://liuyangxiong.cn/tags/Python/"}]},{"title":"Python3 实现Linux中的`ls -l`","text":"虽然打印出来的不太好看，不过基本的已经实现了 1234567891011121314151617# -*- coding: utf-8 -*-import osfrom stat import * # 可以获得文件的详细信息import pwd # 可以获得用户的各类信息from datetime import datetimeOwner = &#123;600:&quot;-rw-------&quot;, 644:&quot;-rw-r--r--&quot;, 700:&quot;-rwx------&quot;, 755:&quot;-rwxr-xr-x&quot;, 711:&quot;-rwx--x--x&quot;, 666:&quot;-rw-rw-rw-&quot;, 777:&quot;-rwxrwxrwx&quot;&#125;for i in os.listdir(&quot;.&quot;): file_chmod = oct(os.stat(i)[ST_MODE])[-3:] file_chmod_int = int(file_chmod) if file_chmod_int in Owner: print(Owner[file_chmod_int],pwd.getpwuid(os.stat(i).st_uid).pw_name,pwd.getpwuid(os.stat(i).st_uid).pw_name,os.path.getsize(i),datetime.fromtimestamp(os.stat(i).st_mtime).strftime(&quot;%m月 %d %H:%M&quot;),i) 下面是运行的结果： 注意: pwd模块只能在Linux中使用,windows是不行的 stat文档pwd文档","path":"2016/12/13/Linux-ls/","date":"12-13","excerpt":"虽然打印出来的不太好看，不过基本的已经实现了","tags":[{"name":"Python","slug":"Python","permalink":"https://liuyangxiong.cn/tags/Python/"}]},{"title":"Python3 判断回数","text":"随便输入一个数判断是不是回数 12345678910111213# -*- coding: utf-8 -*-def Judegent_number(): i = int(input(&quot;&gt;&gt;&gt; &quot;)) s = list(filter(lambda n:int(str(n)[::-1])==n,range(1,i+100))) if i in s: f = str(i) if len(f) &lt;= 3: print(f[:-1],&quot;+&quot;,f[len(f)//2:]) else: print(f[:len(f)//2],&quot;+&quot;,f[len(f)//2:]) print(i,&quot;是回数&quot;) else: print(i,&quot;不是回数&quot;) 这个应该不用解释，有基础的看得懂","path":"2016/12/13/Judegent-number/","date":"12-13","excerpt":"随便输入一个数判断是不是回数","tags":[{"name":"Python","slug":"Python","permalink":"https://liuyangxiong.cn/tags/Python/"}]},{"title":"Linux中部署hexo报错一大堆'ERR！'肿么办？？","text":"最近刚把系统换成了Linux，在换之前一直在想，放在windows里的本地hexo肿么办？因为需要在本地部署hexo，所以拿U盘copy过去也行不通，只能重新部署，最后我只把一些重要的文件copy了～但是，结局并没有那么顺利，当我把所有的东西准备好之后，执行 sudo npm install hexo-cli -g 就给我跳出了一大堆ERR！这给我吓的…. 后来弄啊弄，Google了一下，嘿，最后还是被我找到了解决方法～可以先试试： $ sudo npm install hexo –no-optional 不行的话，试试这个方法，绝对行！！（我就是用这个方法.）在终端里先输入： $ sudo npm cache clean -f$ sudo npm install -g n$ sudo n stable 完了之后，执行： $ sudo npm -g install hexo-cli 然后就看见跳出这样的东西 然后hexo init就成功部署了～嘿嘿～ 最后 hexo s 生成本地网页,hexo的本地部署就完成了～～ 这个主要是解决部署本地Hexo出现ERR！的问题，详细的部署方法可以参考： Mac上搭建基于GitHub的Hexo博客史上最详细的Hexo博客搭建图文教程Hexo官方文档","path":"2016/10/18/Linux本地部署报错ERR!/","date":"10-18","excerpt":"最近刚把系统换成了Linux，在换之前一直在想，放在windows里的本地hexo肿么办？因为需要在本地部署hexo，所以拿U盘copy过去也行不通，只能重新部署，最后我只把一些重要的文件copy了～但是，结局并没有那么顺利，当我把所有的东西准备好之后，执行 sudo npm install hexo-cli -g 就给我跳出了一大堆ERR！这给我吓的….","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://liuyangxiong.cn/tags/Hexo/"}]}]}